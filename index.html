<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Measure Data Logger – Dashboard</title>

<!-- Librerías -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

<!-- Para gráficas interactivas de pronósticos -->
<script src="https://cdn.jsdelivr.net/npm/luxon@3.0.0/build/global/luxon.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.1.0/dist/chartjs-adapter-luxon.min.js"></script>

<style>
:root{
  --ucc-azul:#003366;
  --ucc-verde:#7AC043;
  --gris:#F2F2F2;
  --text:#0b1220;
}

/* Base */
body{font-family:Inter,Arial,Helvetica,sans-serif;margin:0;background:var(--gris);color:var(--text);transition:0.3s}
header{background:var(--ucc-azul);color:#fff;padding:16px 20px;display:flex;align-items:center;justify-content:space-between}
.header-title{font-weight:700;letter-spacing:.6px}
.header-actions{display:flex;gap:10px;align-items:center}

/* Buttons */
.btn{background:var(--ucc-verde);border:none;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600}
.btn.secondary{background:#ffffff;color:var(--ucc-azul);border:1px solid rgba(0,0,0,0.06)}
.icon-btn{background:transparent;border:1px solid rgba(255,255,255,0.08);color:#fff;padding:6px 8px;border-radius:8px;cursor:pointer}

/* Container */
.container{max-width:1200px;margin:22px auto;padding:0 16px}

/* KPI Cards row */
.kpi-row{display:grid;grid-template-columns:repeat(3,1fr);gap:14px;margin-bottom:18px}
.kpi-card{background:#fff;border-radius:10px;padding:16px;box-shadow:0 6px 18px rgba(11,18,32,0.06);display:flex;align-items:center;gap:12px}
.kpi-icon{width:56px;height:56px;border-radius:8px;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,var(--ucc-azul),#0a2b5a);color:#fff}
.kpi-body{flex:1}
.kpi-title{font-size:13px;color:#334155;margin:0 0 6px 0}
.kpi-value{font-size:22px;font-weight:700;color:var(--ucc-azul)}
.kpi-meta{font-size:12px;color:#6b7280;margin-top:6px}

/* Middle: charts + controls */
.charts-panel{display:grid;grid-template-columns:1fr;gap:16px;margin-bottom:18px}
.controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-bottom:8px}
.range-btn{padding:8px 12px;border-radius:8px;border:1px solid rgba(0,0,0,0.06);background:#fff;cursor:pointer}
.range-btn.active{background:var(--ucc-azul);color:#fff;border-color:var(--ucc-azul)}

/* Selector de variables */
.variable-selector{
  display:flex;
  gap:8px;
  margin-bottom:15px;
  flex-wrap:wrap;
}
.variable-btn{
  padding:8px 15px;
  border-radius:8px;
  border:1px solid rgba(0,0,0,0.06);
  background:#fff;
  cursor:pointer;
  font-size:13px;
  transition:all 0.3s;
}
.variable-btn.active{
  background:var(--ucc-azul);
  color:#fff;
  border-color:var(--ucc-azul);
}

/* canvas wrapper */
.canvas-card{background:#fff;padding:14px;border-radius:10px;box-shadow:0 6px 18px rgba(11,18,32,0.06)}
.canvas-title{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
/* Limitar tamaño de las gráficas */
.canvas-card canvas {
  max-height: 250px !important;
  height: 250px !important;
}

/* Sección de parámetros del modelo */
.model-params-card {
  background: #fff;
  padding: 14px;
  border-radius: 10px;
  box-shadow: 0 6px 18px rgba(11,18,32,0.06);
  margin-bottom: 20px;
  display: none;
}
.params-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 15px;
  margin-top: 15px;
}
.param-group {
  background: #f8f9fa;
  padding: 12px;
  border-radius: 8px;
  border-left: 4px solid var(--ucc-azul);
}
.param-title {
  font-weight: bold;
  color: var(--ucc-azul);
  margin-bottom: 8px;
  font-size: 14px;
}
.param-item {
  display: flex;
  justify-content: space-between;
  margin-bottom: 5px;
  font-size: 13px;
}
.param-label {
  color: #666;
}
.param-value {
  font-weight: 600;
  color: #000;
}
.equation-box {
  background: #f0f7ff;
  padding: 15px;
  border-radius: 8px;
  border: 1px solid #d1e7ff;
  font-family: 'Courier New', monospace;
  font-size: 14px;
  line-height: 1.5;
  margin-top: 10px;
  white-space: pre-wrap;
  word-break: break-all;
}

/* Table area */
.table-card{background:#fff;padding:14px;border-radius:10px;box-shadow:0 6px 18px rgba(11,18,32,0.06);margin-bottom:40px}
.table-controls{display:flex;flex-wrap:wrap;gap:8px;justify-content:space-between;margin-bottom:10px}
.table-search{display:flex;gap:8px;align-items:center}
.input{padding:8px 10px;border-radius:8px;border:1px solid #e6e9ef}

/* Table style */
table{width:100%;border-collapse:collapse}
th,td{padding:10px;border-bottom:1px solid #eef2f6;text-align:center;font-size:13px}
th{background:var(--ucc-azul);color:#fff;border-radius:6px}

/* Pestañas de pronósticos */
.forecast-tabs {
  display: flex;
  gap: 5px;
  margin-bottom: 15px;
  border-bottom: 2px solid #e0e0e0;
  padding-bottom: 10px;
}
.forecast-tab {
  padding: 8px 15px;
  background: #f5f5f5;
  border: none;
  border-radius: 6px 6px 0 0;
  cursor: pointer;
  font-size: 13px;
  font-weight: 500;
  transition: all 0.3s;
  position: relative;
}
.forecast-tab.active {
  background: var(--ucc-azul);
  color: white;
  border-bottom: 3px solid var(--ucc-verde);
}
.forecast-tab.loaded {
  background: #e8f5e8;
  border-left: 3px solid var(--ucc-verde);
}
.forecast-tab.error {
  background: #ffebee;
  border-left: 3px solid #f44336;
}
.forecast-tab .tab-badge {
  position: absolute;
  top: -5px;
  right: -5px;
  background: var(--ucc-verde);
  color: white;
  font-size: 10px;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* Indicador de carga */
.loading-spinner {
  display: inline-block;
  width: 16px;
  height: 16px;
  border: 2px solid #f3f3f3;
  border-top: 2px solid var(--ucc-verde);
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin-right: 8px;
}
@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Estadísticas rápidas */
.quick-stats {
  display: flex;
  gap: 15px;
  margin-top: 15px;
  flex-wrap: wrap;
}
.stat-card {
  background: #f8f9fa;
  padding: 12px;
  border-radius: 8px;
  flex: 1;
  min-width: 150px;
  border-left: 4px solid var(--ucc-azul);
}
.stat-card .stat-title {
  font-size: 12px;
  color: #666;
  margin-bottom: 5px;
}
.stat-card .stat-value {
  font-size: 18px;
  font-weight: bold;
  color: var(--ucc-azul);
}
.stat-card .stat-subtitle {
  font-size: 10px;
  color: #999;
}

/* Responsive */
@media (max-width:900px){
  .kpi-row{grid-template-columns:repeat(2,1fr)}
  header{padding:12px}
  #pdfBtn{display:none} /* hide long buttons in small */
  .params-grid {
    grid-template-columns: 1fr;
  }
  .quick-stats {
    flex-direction: column;
  }
}
@media (max-width:560px){
  .kpi-row{grid-template-columns:1fr}
  .controls{flex-direction:column;align-items:flex-start}
  .charts-panel{gap:12px}
  header{flex-direction:column;align-items:flex-start;gap:8px}
  .forecast-tabs {
    flex-wrap: wrap;
  }
  .variable-selector{
    flex-direction:column;
  }
}

/* Dark mode */
body.dark{background:#0b1220;color:#e6eef8}
body.dark .kpi-card, 
body.dark .canvas-card, 
body.dark .table-card,
body.dark .model-params-card {background:#0f1724;box-shadow:none}
body.dark th{background:#001f3f}
body.dark .kpi-value{color:#7AC043}
body.dark .param-group {
  background: #1a2332;
  border-left-color: var(--ucc-verde);
}
body.dark .equation-box {
  background: #1a2332;
  border-color: #2a3a52;
}
body.dark .forecast-tab:not(.active) {
  background: #1a2332;
  color: #e6eef8;
}
body.dark .stat-card {
  background: #1a2332;
  border-left-color: var(--ucc-verde);
}
body.dark .variable-btn{
  background:#1a2332;
  color:#e6eef8;
}
body.dark .variable-btn.active{
  background:var(--ucc-azul);
  color:#fff;
}

/* Leyenda mejorada */
.chart-legend {
  display: flex;
  flex-wrap: wrap;
  gap: 15px;
  justify-content: center;
  margin-top: 10px;
  padding: 10px;
  background: #f8f9fa;
  border-radius: 8px;
  font-size: 12px;
}
.legend-item {
  display: flex;
  align-items: center;
  gap: 5px;
}
.legend-color {
  width: 15px;
  height: 15px;
  border-radius: 3px;
}

/* Pronósticos por hora estilo clima */
.hourly-forecast-container {
  background: #fff;
  border-radius: 10px;
  padding: 16px;
  box-shadow: 0 6px 18px rgba(11,18,32,0.06);
  margin-top: 16px;
  display: none;
}
.hourly-forecast-title {
  font-size: 16px;
  font-weight: 700;
  color: var(--ucc-azul);
  margin-bottom: 16px;
  display: flex;
  align-items: center;
  gap: 8px;
}
.hourly-forecast-scroll {
  overflow-x: auto;
  overflow-y: hidden;
  -webkit-overflow-scrolling: touch;
  scrollbar-width: thin;
  scrollbar-color: var(--ucc-verde) #f0f0f0;
}
.hourly-forecast-scroll::-webkit-scrollbar {
  height: 8px;
}
.hourly-forecast-scroll::-webkit-scrollbar-track {
  background: #f0f0f0;
  border-radius: 10px;
}
.hourly-forecast-scroll::-webkit-scrollbar-thumb {
  background: var(--ucc-verde);
  border-radius: 10px;
}
.hourly-forecast {
  display: flex;
  gap: 12px;
  padding-bottom: 10px;
  min-width: min-content;
}
.hour-card {
  background: linear-gradient(180deg, #f8f9fa 0%, #e9ecef 100%);
  border-radius: 12px;
  padding: 12px 16px;
  min-width: 90px;
  text-align: center;
  border: 2px solid transparent;
  transition: all 0.3s;
  cursor: pointer;
  position: relative;
}
.hour-card:hover {
  transform: translateY(-3px);
  border-color: var(--ucc-verde);
  box-shadow: 0 4px 12px rgba(122, 192, 67, 0.3);
}
.hour-card.current {
  background: linear-gradient(180deg, var(--ucc-azul) 0%, #002347 100%);
  color: white;
  border-color: var(--ucc-verde);
}
.hour-time {
  font-size: 11px;
  font-weight: 600;
  color: #666;
  margin-bottom: 8px;
  text-transform: uppercase;
}
.hour-card.current .hour-time {
  color: rgba(255,255,255,0.9);
}
.hour-day {
  font-size: 13px;
  font-weight: 700;
  margin-bottom: 4px;
  color: var(--ucc-azul);
}
.hour-card.current .hour-day {
  color: white;
}
.hour-icon {
  width: 48px;
  height: 48px;
  margin: 8px auto;
  display: flex;
  align-items: center;
  justify-content: center;
  background: white;
  border-radius: 50%;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}
.hour-card.current .hour-icon {
  background: rgba(255,255,255,0.2);
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}
.hour-value {
  font-size: 22px;
  font-weight: 700;
  color: var(--ucc-azul);
  margin: 8px 0;
}
.hour-card.current .hour-value {
  color: white;
}
.hour-range {
  font-size: 10px;
  color: #999;
  margin-top: 4px;
}
.hour-card.current .hour-range {
  color: rgba(255,255,255,0.7);
}
.hour-label {
  font-size: 10px;
  color: #666;
  margin-top: 4px;
  font-weight: 500;
}
.hour-card.current .hour-label {
  color: rgba(255,255,255,0.8);
}
.forecast-badge {
  position: absolute;
  top: 8px;
  right: 8px;
  background: var(--ucc-verde);
  color: white;
  font-size: 9px;
  padding: 2px 6px;
  border-radius: 10px;
  font-weight: 600;
}

/* Dark mode para pronósticos por hora */
body.dark .hourly-forecast-container {
  background: #0f1724;
}
body.dark .hour-card {
  background: linear-gradient(180deg, #1a2332 0%, #0f1724 100%);
  color: #e6eef8;
}
body.dark .hour-card:hover {
  border-color: var(--ucc-verde);
}
body.dark .hour-time {
  color: #999;
}
body.dark .hour-day {
  color: var(--ucc-verde);
}
body.dark .hour-value {
  color: #e6eef8;
}
body.dark .hour-label {
  color: #999;
}
body.dark .hour-icon {
  background: rgba(255,255,255,0.05);
}
</style>
</head>
<body>

<header>
  <div class="header-title">MEASURE DATA LOGGER – DASHBOARD</div>
  <div class="header-actions">
    <button id="pdfBtn" class="btn">Exportar PDF</button>
    <button id="xlsBtn" class="btn">Descargar Excel</button>
    <button id="csvBtn" class="btn secondary">CSV</button>
    <button id="modoOscuroBtn" class="icon-btn">Modo oscuro</button>
  </div>
</header>

<div class="container" id="contentPDF">
  <!-- KPI Cards -->
  <div class="kpi-row">
    <div class="kpi-card">
      <div class="kpi-icon" aria-hidden="true">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <rect x="9" y="3" width="6" height="18" rx="3" stroke="#fff" stroke-width="2" fill="none"/>
          <circle cx="12" cy="19" r="2" fill="#fff"/>
          <line x1="12" y1="8" x2="12" y2="16" stroke="#fff" stroke-width="2" stroke-linecap="round"/>
        </svg>
      </div>
      <div class="kpi-body">
        <div class="kpi-title">Temperatura (°C)</div>
        <div class="kpi-value" id="card_temp">--</div>
        <div class="kpi-meta" id="meta_temp">Última: --</div>
      </div>
    </div>

    <div class="kpi-card">
      <div class="kpi-icon" aria-hidden="true">
        <svg width="22" height="22" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z" stroke="#fff" stroke-width="2" fill="none"/>
        </svg>
      </div>
      <div class="kpi-body">
        <div class="kpi-title">Humedad (%)</div>
        <div class="kpi-value" id="card_hum">--</div>
        <div class="kpi-meta" id="meta_hum">Última: --</div>
      </div>
    </div>

    <div class="kpi-card">
      <div class="kpi-icon" aria-hidden="true">
        <svg width="22" height="22" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <circle cx="12" cy="12" r="4" fill="#fff"/>
          <line x1="12" y1="3" x2="12" y2="5" stroke="#fff" stroke-width="2" stroke-linecap="round"/>
          <line x1="12" y1="19" x2="12" y2="21" stroke="#fff" stroke-width="2" stroke-linecap="round"/>
          <line x1="4.22" y1="4.22" x2="5.64" y2="5.64" stroke="#fff" stroke-width="2" stroke-linecap="round"/>
          <line x1="18.36" y1="18.36" x2="19.78" y2="19.78" stroke="#fff" stroke-width="2" stroke-linecap="round"/>
          <line x1="3" y1="12" x2="5" y2="12" stroke="#fff" stroke-width="2" stroke-linecap="round"/>
          <line x1="19" y1="12" x2="21" y2="12" stroke="#fff" stroke-width="2" stroke-linecap="round"/>
          <line x1="4.22" y1="19.78" x2="5.64" y2="18.36" stroke="#fff" stroke-width="2" stroke-linecap="round"/>
          <line x1="18.36" y1="5.64" x2="19.78" y2="4.22" stroke="#fff" stroke-width="2" stroke-linecap="round"/>
        </svg>
      </div>
      <div class="kpi-body">
        <div class="kpi-title">Radiación (W/m²)</div>
        <div class="kpi-value" id="card_rad">--</div>
        <div class="kpi-meta" id="meta_rad">Última: --</div>
      </div>
    </div>

    <div class="kpi-card">
      <div class="kpi-icon" aria-hidden="true">
        <svg width="22" height="22" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <circle cx="7" cy="18" r="2" fill="#fff"/>
          <circle cx="12" cy="14" r="2" fill="#fff"/>
          <circle cx="17" cy="10" r="2" fill="#fff"/>
          <circle cx="9" cy="8" r="1.5" fill="#fff"/>
          <circle cx="14" cy="17" r="1.5" fill="#fff"/>
        </svg>
      </div>
      <div class="kpi-body">
        <div class="kpi-title">PM10 (µg/m³)</div>
        <div class="kpi-value" id="card_pm10">--</div>
        <div class="kpi-meta" id="meta_pm10">Última: --</div>
      </div>
    </div>

    <div class="kpi-card">
      <div class="kpi-icon" aria-hidden="true">
        <svg width="22" height="22" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <circle cx="6" cy="17" r="1.5" fill="#fff"/>
          <circle cx="11" cy="13" r="1.5" fill="#fff"/>
          <circle cx="16" cy="9" r="1.5" fill="#fff"/>
          <circle cx="8" cy="10" r="1" fill="#fff"/>
          <circle cx="13" cy="16" r="1" fill="#fff"/>
          <circle cx="18" cy="15" r="1" fill="#fff"/>
          <circle cx="9" cy="19" r="1" fill="#fff"/>
        </svg>
      </div>
      <div class="kpi-body">
        <div class="kpi-title">PM2.5 (µg/m³)</div>
        <div class="kpi-value" id="card_pm25">--</div>
        <div class="kpi-meta" id="meta_pm25">Última: --</div>
      </div>
    </div>
  </div>

  <!-- Controls & Charts -->
  <div class="charts-panel">
    <div class="controls">
      <div>
        <button class="range-btn" data-range="24h">Últimas 24h</button>
        <button class="range-btn" data-range="7d">Última semana</button>
        <button class="range-btn" data-range="all">Todo</button>
        <button class="range-btn" data-range="forecast" id="forecastBtn">
          Pronósticos
        </button>
      </div>
      
      <!-- Fechas personalizadas -->
      <div style="margin-left: auto; display: flex; gap: 8px; align-items: center">
        <label style="font-size: 13px; color: #6b7280">Desde</label>
        <input type="datetime-local" id="fromInput" class="input" />
        <label style="font-size: 13px; color: #6b7280">Hasta</label>
        <input type="datetime-local" id="toInput" class="input" />
        <button id="applyRange" class="range-btn">Aplicar</button>
      </div>
    </div>

    <!-- Selector de variables (oculto en modo pronóstico) -->
    <div class="variable-selector" id="variableSelector">
      <button class="variable-btn active" data-variable="temp">Temperatura</button>
      <button class="variable-btn" data-variable="hum">Humedad</button>
      <button class="variable-btn" data-variable="rad">Radiación</button>
      <button class="variable-btn" data-variable="pm10">PM10</button>
      <button class="variable-btn" data-variable="pm25">PM2.5</button>
    </div>

    <!-- Gráfica única para variables históricas -->
    <div class="canvas-card" id="mainChartCard">
      <div class="canvas-title"><strong id="mainChartTitle">Temperatura (°C)</strong><small id="main-note"></small></div>
      <canvas id="mainChart"></canvas>
    </div>

    <!-- Pronósticos por hora estilo clima -->
    <div class="hourly-forecast-container" id="hourlyForecastContainer">
      <div class="hourly-forecast-title">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M12 2L2 7L12 12L22 7L12 2Z" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/>
          <path d="M2 17L12 22L22 17" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M2 12L12 17L22 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        Pronóstico por Hora
      </div>
      <div class="hourly-forecast-scroll">
        <div class="hourly-forecast" id="hourlyForecast">
          <!-- Las tarjetas de pronóstico se cargarán aquí -->
        </div>
      </div>
    </div>
    
    <!-- Sección de Parámetros del Modelo SARIMA -->
    <div class="model-params-card" id="modelParamsCard">
      <div class="canvas-title">
        <strong>Parámetros del Modelo SARIMA</strong>
        <small id="modelInfo">Selecciona una variable</small>
      </div>
      <div class="params-grid" id="paramsGrid">
        <!-- Los parámetros se cargarán aquí dinámicamente -->
      </div>
    </div>
    
    <!-- Gráfica de Pronósticos (oculta inicialmente) -->
    <div class="canvas-card" id="forecastChartContainer" style="display: none;">
      <div class="canvas-title">
        <strong id="forecastTitle">Pronósticos SARIMA</strong>
        <div>
          <span class="loading-spinner" id="forecastLoading" style="display: none;"></span>
          <small id="forecastInfo">Selecciona una variable para ver el pronóstico</small>
        </div>
      </div>
      
      <!-- Pestañas de variables -->
      <div class="forecast-tabs" id="forecastTabs">
        <button class="forecast-tab active" data-variable="temperature" data-name="Temperatura">
          Temperatura
        </button>
        <button class="forecast-tab" data-variable="humidity" data-name="Humedad">
          Humedad
        </button>
        <button class="forecast-tab" data-variable="pm2.5" data-name="PM2.5">
          PM2.5
        </button>
        <button class="forecast-tab" data-variable="pm10" data-name="PM10">
          PM10
        </button>
      </div>
      
      <!-- Estadísticas rápidas -->
      <div class="quick-stats" id="quickStats" style="display: none;">
        <!-- Las estadísticas se cargarán aquí -->
      </div>
      
      <canvas id="forecastChart"></canvas>
      
      <!-- Leyenda mejorada -->
      <div class="chart-legend" id="chartLegend">
        <div class="legend-item">
          <div class="legend-color" style="background: black; border: 2px solid black;"></div>
          <span>Datos Históricos</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: red; border: 2px solid red;"></div>
          <span>Pronóstico</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: rgba(0, 255, 0, 0.3); border: 1px solid #00c853;"></div>
          <span>Confianza 80%</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: rgba(255, 255, 0, 0.3); border: 1px solid #ffd600;"></div>
          <span>Confianza 95%</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: transparent; border: 1px dashed blue;"></div>
          <span>Límite Permitido</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Tabla principal con datos históricos -->
  <div class="table-card">
    <div class="table-controls">
      <div class="table-search">
        <input id="searchInput" class="input" placeholder="Buscar..." />
        <input id="filterFrom" type="date" class="input" />
        <input id="filterTo" type="date" class="input" />
        <button id="clearFilters" class="range-btn">Limpiar</button>
      </div>
      <div>
        <button id="exportCSV" class="range-btn">Exportar CSV</button>
        <button id="exportXLS" class="range-btn">Exportar Excel</button>
      </div>
    </div>

    <table id="dataTable" aria-live="polite">
      <thead>
        <tr><th>Fecha</th><th>Temp (°C)</th><th>Humedad (%)</th><th>Radiación (W/m²)</th><th>PM10 (µg/m³)</th><th>PM2.5 (µg/m³)</th></tr>
      </thead>
      <tbody id="dataTableBody">
        <!-- Los datos históricos se cargarán aquí -->
      </tbody>
    </table>
  </div>

</div>

<script>
/* -------------------------
  Config y variables
------------------------- */
const API_URL = "api/obtener_datos.php"; // tu API devuelve JSON ordenado por fecha desc
let rawData = []; // data completa
let filtered = []; // filtro por rango
const charts = {};
let currentVariable = 'temp'; // Variable actualmente seleccionada

/* ---------- util: parse fecha ---------- */
function parseDate(s){ // acepta 'YYYY-MM-DD HH:MM:SS' o ISO
  if(!s) return null;
  // intenta ISO primero
  const d = new Date(s.replace(' ', 'T'));
  return isNaN(d) ? new Date(s) : d;
}

/* ---------- fetch data ---------- */
async function loadData(){
  try{
    const res = await fetch(API_URL);
    const data = await res.json();
    // normalizar: asegurar campos: fecha_hora, temperatura, humedad, radiacion, pm10, pm25
    rawData = data.map(r => ({
      fecha: r.fecha_hora || r.fecha || r.fecha_hora,
      temperatura: r.temperatura !== undefined ? Number(r.temperatura) : null,
      humedad: r.humedad !== undefined ? Number(r.humedad) : null,
      radiacion: r.radiacion !== undefined ? Number(r.radiacion) : null,
      pm10: r.pm10 !== undefined ? Number(r.pm10) : null,
      pm25: r.pm25 !== undefined ? Number(r.pm25) : null
    })).filter(x=>x.fecha).sort((a,b)=> new Date(a.fecha) - new Date(b.fecha)); // asc
    applyRange('24h'); // default
    updateKPI();
    
    // Actualizar tabla principal con datos históricos
    updateHistoricalTable();
  }catch(e){
    console.error("API error",e);
  }
}

/* ---------- Actualizar tabla con datos históricos ---------- */
function updateHistoricalTable() {
  const tbody = document.getElementById('dataTableBody');
  if (!tbody) return;
  
  tbody.innerHTML = '';
  
  if (!rawData.length) {
    tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; padding: 20px;">No hay datos disponibles</td></tr>';
    return;
  }
  
  // Mostrar últimos 200 registros en orden descendente (más recientes primero)
  const rows = [...rawData].slice(-200).reverse();
  
  rows.forEach(r => {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${new Date(r.fecha).toLocaleString('es-ES', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      })}</td>
      <td>${r.temperatura !== null ? r.temperatura.toFixed(2) : '--'}</td>
      <td>${r.humedad !== null ? r.humedad.toFixed(2) : '--'}</td>
      <td>${r.radiacion !== null ? r.radiacion.toFixed(2) : '--'}</td>
      <td>${r.pm10 !== null ? r.pm10.toFixed(2) : '--'}</td>
      <td>${r.pm25 !== null ? r.pm25.toFixed(2) : '--'}</td>
    `;
    tbody.appendChild(tr);
  });
}

/* ---------- range helpers ---------- */
function applyRange(range, from=null, to=null){
  const now = new Date();
  let start;
  if(range==='24h') start = new Date(now.getTime() - 24*3600*1000);
  else if(range==='7d') start = new Date(now.getTime() - 7*24*3600*1000);
  else if(range==='all') start = new Date(0);
  else if(range==='custom'){ start = from; }

  const end = to || new Date();
  filtered = rawData.filter(r => {
    const d = parseDate(r.fecha);
    return d >= start && d <= end;
  });
  renderMainChart();
}

/* ---------- render KPIs ---------- */
function updateKPI(){
  if(!rawData.length) return;
  const last = rawData[rawData.length-1];
  document.getElementById('card_temp').innerText = last.temperatura !== null ? last.temperatura.toFixed(2) : '--';
  document.getElementById('card_hum').innerText = last.humedad !== null ? last.humedad.toFixed(2) : '--';
  document.getElementById('card_rad').innerText = last.radiacion !== null ? last.radiacion.toFixed(2) : '--';
  document.getElementById('card_pm10').innerText = last.pm10 !== null ? last.pm10.toFixed(2) : '--';
  document.getElementById('card_pm25').innerText = last.pm25 !== null ? last.pm25.toFixed(2) : '--';

  const timeStr = new Date(last.fecha).toLocaleString('es-ES', {
    day: '2-digit',
    month: '2-digit',
    year: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  });
  document.getElementById('meta_temp').innerText = 'Última: ' + timeStr;
  document.getElementById('meta_hum').innerText = 'Última: ' + timeStr;
  document.getElementById('meta_rad').innerText = 'Última: ' + timeStr;
  document.getElementById('meta_pm10').innerText = 'Última: ' + timeStr;
  document.getElementById('meta_pm25').innerText = 'Última: ' + timeStr;
}

/* ---------- render main chart (variable seleccionada) ---------- */
function renderMainChart(){
  const times = filtered.map(r=> r.fecha);
  let data, label, color;
  
  // Obtener datos según la variable seleccionada
  switch(currentVariable) {
    case 'temp':
      data = filtered.map(r=> r.temperatura);
      label = 'Temperatura (°C)';
      color = '#003366';
      break;
    case 'hum':
      data = filtered.map(r=> r.humedad);
      label = 'Humedad (%)';
      color = '#7AC043';
      break;
    case 'rad':
      data = filtered.map(r=> r.radiacion);
      label = 'Radiación (W/m²)';
      color = '#003366';
      break;
    case 'pm10':
      data = filtered.map(r=> r.pm10);
      label = 'PM10 (µg/m³)';
      color = '#7AC043';
      break;
    case 'pm25':
      data = filtered.map(r=> r.pm25);
      label = 'PM2.5 (µg/m³)';
      color = '#003366';
      break;
  }
  
  // Actualizar título
  document.getElementById('mainChartTitle').innerText = label;
  
  // Renderizar gráfica
  renderChart('mainChart', label, times, data, color);
  
  // Cargar pronósticos por hora para la variable actual
  loadHourlyForecast();
}

/* ---------- Cargar y mostrar pronósticos por hora ---------- */
async function loadHourlyForecast() {
  const container = document.getElementById('hourlyForecastContainer');
  const forecastDiv = document.getElementById('hourlyForecast');
  
  if (!container || !forecastDiv) return;
  
  // Mapear variable actual a variable de pronóstico
  const variableMap = {
    'temp': 'temperature',
    'hum': 'humidity',
    'pm10': 'pm10',
    'pm25': 'pm2.5'
  };
  
  const forecastVariable = variableMap[currentVariable];
  
  // Si no hay mapeo o es radiación (sin pronóstico), ocultar
  if (!forecastVariable || currentVariable === 'rad') {
    container.style.display = 'none';
    return;
  }
  
  try {
    // Mostrar contenedor
    container.style.display = 'block';
    forecastDiv.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">Cargando pronósticos...</div>';
    
    // Cargar datos de pronóstico
    const fileName = getForecastFileName(forecastVariable);
    const response = await fetch(`${FORECAST_BASE_URL}${fileName}?t=${Date.now()}`);
    
    if (!response.ok) {
      throw new Error(`Error ${response.status}`);
    }
    
    const data = await response.json();
    
    if (!data.pronosticos || data.pronosticos.length === 0) {
      forecastDiv.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">No hay pronósticos disponibles</div>';
      return;
    }
    
    // Obtener datos históricos más recientes para comparar
    const lastHistorical = rawData.length > 0 ? rawData[rawData.length - 1] : null;
    
    // Generar tarjetas (mostrar hasta 12 horas)
    const hoursToShow = Math.min(12, data.pronosticos.length);
    let cardsHTML = '';
    
    // Agregar tarjeta actual si hay datos históricos
    if (lastHistorical) {
      const currentValue = getCurrentValue(lastHistorical);
      const now = new Date(lastHistorical.fecha);
      
      cardsHTML += `
        <div class="hour-card current">
          <div class="hour-time">${now.toLocaleTimeString('es-ES', {hour: '2-digit', minute: '2-digit'})}</div>
          <div class="hour-day">${getDayName(now)}</div>
          <div class="hour-icon">
            ${getVariableIcon(currentVariable, currentValue)}
          </div>
          <div class="hour-value">${currentValue !== null ? currentValue.toFixed(1) : '--'}</div>
          <div class="hour-label">${getUnit(forecastVariable)}</div>
          <div class="hour-label" style="margin-top: 4px; font-weight: 600;">ACTUAL</div>
        </div>
      `;
    }
    
    // Agregar tarjetas de pronóstico
    for (let i = 0; i < hoursToShow; i++) {
      const forecast = data.pronosticos[i];
      const date = new Date(forecast.fecha);
      const value = parseFloat(forecast.pronostico);
      const conf80Min = parseFloat(forecast.confianza_80_min);
      const conf80Max = parseFloat(forecast.confianza_80_max);
      
      cardsHTML += `
        <div class="hour-card" data-index="${i}">
          <span class="forecast-badge">+${i + 1}h</span>
          <div class="hour-time">${date.toLocaleTimeString('es-ES', {hour: '2-digit', minute: '2-digit'})}</div>
          <div class="hour-day">${getDayName(date)}</div>
          <div class="hour-icon">
            ${getVariableIcon(currentVariable, value)}
          </div>
          <div class="hour-value">${value.toFixed(1)}</div>
          <div class="hour-label">${getUnit(forecastVariable)}</div>
          ${conf80Min && conf80Max ? `<div class="hour-range">${conf80Min.toFixed(1)} - ${conf80Max.toFixed(1)}</div>` : ''}
        </div>
      `;
    }
    
    forecastDiv.innerHTML = cardsHTML;
    
  } catch (error) {
    console.error('Error cargando pronósticos por hora:', error);
    forecastDiv.innerHTML = '<div style="padding: 20px; text-align: center; color: #f44336;">Error al cargar pronósticos</div>';
  }
}

/* ---------- Funciones auxiliares para pronósticos por hora ---------- */
function getCurrentValue(data) {
  switch(currentVariable) {
    case 'temp': return data.temperatura;
    case 'hum': return data.humedad;
    case 'rad': return data.radiacion;
    case 'pm10': return data.pm10;
    case 'pm25': return data.pm25;
    default: return null;
  }
}

function getDayName(date) {
  const days = ['DOM', 'LUN', 'MAR', 'MIÉ', 'JUE', 'VIE', 'SÁB'];
  return days[date.getDay()];
}

function getVariableIcon(variable, value) {
  let color = '#003366';
  let icon = '';
  
  switch(variable) {
    case 'temp':
      // Color basado en temperatura
      if (value < 15) color = '#2196F3';
      else if (value < 25) color = '#4CAF50';
      else if (value < 30) color = '#FF9800';
      else color = '#F44336';
      
      icon = `
        <svg width="32" height="32" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <rect x="9" y="3" width="6" height="14" rx="3" stroke="${color}" stroke-width="2" fill="none"/>
          <circle cx="12" cy="19" r="3" fill="${color}"/>
          <line x1="12" y1="8" x2="12" y2="16" stroke="${color}" stroke-width="2"/>
        </svg>
      `;
      break;
      
    case 'hum':
      color = '#2196F3';
      icon = `
        <svg width="32" height="32" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z" stroke="${color}" stroke-width="2" fill="${color}" fill-opacity="0.3"/>
        </svg>
      `;
      break;
      
    case 'pm10':
    case 'pm25':
      // Color basado en calidad del aire
      if (value < 50) color = '#4CAF50';
      else if (value < 100) color = '#FFEB3B';
      else if (value < 150) color = '#FF9800';
      else color = '#F44336';
      
      icon = `
        <svg width="32" height="32" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <circle cx="7" cy="17" r="2" fill="${color}"/>
          <circle cx="12" cy="13" r="2" fill="${color}"/>
          <circle cx="17" cy="9" r="2" fill="${color}"/>
          <circle cx="9" cy="9" r="1.5" fill="${color}" opacity="0.6"/>
          <circle cx="14" cy="16" r="1.5" fill="${color}" opacity="0.6"/>
        </svg>
      `;
      break;
      
    default:
      icon = `<svg width="32" height="32" viewBox="0 0 24 24"></svg>`;
  }
  
  return icon;
}

/* ---------- Chart render (single function) ---------- */
function renderChart(id,label,labels,data,color){
  const ctx = document.getElementById(id).getContext('2d');
  if(charts[id]) charts[id].destroy();
  charts[id] = new Chart(ctx,{
    type:'line',
    data:{
      labels: labels,
      datasets:[{
        label:label,
        data:data,
        borderColor: color,
        backgroundColor: color + '33',
        fill:true,
        tension:0.2,
        pointRadius:0
      }]
    },
    options:{
      responsive:true,
      maintainAspectRatio:false,
      scales:{
        x:{display:false},
        y:{beginAtZero:false}
      },
      plugins:{
        legend:{display:false},
        tooltip:{
          mode:'index',
          intersect:false,
          callbacks: {
            label: function(context) {
              let label = context.dataset.label || '';
              if (label) {
                label += ': ';
              }
              label += context.parsed.y.toFixed(2);
              return label;
            }
          }
        }
      },
      hover: {
        mode: 'index',
        intersect: false
      }
    }
  });
  document.getElementById(id).style.height = '220px';
}

/* ---------- variable selector buttons ---------- */
document.querySelectorAll('.variable-btn').forEach(btn=>{
  btn.addEventListener('click', (e)=>{
    document.querySelectorAll('.variable-btn').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    currentVariable = btn.dataset.variable;
    renderMainChart();
  });
});

/* ---------- range buttons ---------- */
document.querySelectorAll('.range-btn[data-range]').forEach(btn=>{
  btn.addEventListener('click', (e)=>{
    document.querySelectorAll('.range-btn').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    
    if(btn.dataset.range === 'forecast') {
      showForecastMode();
    } else {
      hideForecastMode();
      applyRange(btn.dataset.range);
    }
  });
});

/* ---------- apply custom ---------- */
document.getElementById('applyRange').addEventListener('click', ()=>{
  const from = document.getElementById('fromInput').value;
  const to = document.getElementById('toInput').value;
  if(!from || !to) return alert('Seleccione ambas fechas');
  applyRange('custom', new Date(from), new Date(to));
});

/* ---------- search & filter ---------- */
document.getElementById('searchInput').addEventListener('input', (e)=>{
  const q = e.target.value.toLowerCase();
  const tbody = document.querySelector('#dataTableBody');
  Array.from(tbody.querySelectorAll('tr')).forEach(tr=>{
    tr.style.display = tr.innerText.toLowerCase().includes(q) ? '' : 'none';
  });
});

document.getElementById('filterFrom').addEventListener('change', applyDateFilter);
document.getElementById('filterTo').addEventListener('change', applyDateFilter);
document.getElementById('clearFilters').addEventListener('click', ()=>{
  document.getElementById('filterFrom').value='';
  document.getElementById('filterTo').value='';
  renderMainChart();
});

function applyDateFilter(){
  const f=document.getElementById('filterFrom').value;
  const t=document.getElementById('filterTo').value;
  if(!f && !t) return renderMainChart();
  const from = f ? new Date(f) : new Date(0);
  const to = t ? new Date(t + 'T23:59:59') : new Date();
  filtered = rawData.filter(r=>{ const d=parseDate(r.fecha); return d>=from && d<=to; });
  renderMainChart();
}

/* ---------- CSV / XLS / PDF export ---------- */
function exportToCSV(filename){
  const rows = document.querySelectorAll('#dataTable tr');
  let csv = [];
  rows.forEach(r=>{
    const cols = Array.from(r.querySelectorAll('th,td')).map(c=> '"' + c.innerText.replace(/"/g,'""') + '"');
    csv.push(cols.join(','));
  });
  const blob = new Blob([csv.join('\n')],{type:'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = filename; a.click(); URL.revokeObjectURL(url);
}

function exportToXLSX(filename){
  const table = document.getElementById('dataTable');
  const wb = XLSX.utils.table_to_book(table, {sheet:"Lecturas"});
  XLSX.writeFile(wb, filename);
}

document.getElementById('exportCSV').addEventListener('click', ()=> exportToCSV('datos_mediciones.csv'));
document.getElementById('exportXLS').addEventListener('click', ()=> exportToXLSX('datos_mediciones.xlsx'));
document.getElementById('csvBtn').addEventListener('click', ()=> exportToCSV('datos_mediciones.csv'));
document.getElementById('xlsBtn').addEventListener('click', ()=> exportToXLSX('datos_mediciones.xlsx'));

/* ---------- PDF & dark ---------- */
document.getElementById('pdfBtn').addEventListener('click', ()=>{
  html2canvas(document.querySelector('#contentPDF'), {scale:1.8}).then(canvas=>{
    const img=canvas.toDataURL('image/png');
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF('p','mm','a4');
    const pdfWidth = 210;
    const pdfHeight = (canvas.height * pdfWidth) / canvas.width;
    pdf.addImage(img,'PNG',0,0,pdfWidth,pdfHeight);
    pdf.save('Reporte_MeasureDataLogger.pdf');
  });
});

document.getElementById('modoOscuroBtn').addEventListener('click', ()=>{
  document.body.classList.toggle('dark');
  document.getElementById('modoOscuroBtn').innerText = document.body.classList.contains('dark') ? 'Modo claro' : 'Modo oscuro';
});

/* ============================
   MÓDULO DE PRONÓSTICOS SARIMA - SIN TABLA
   ============================ */
  
const FORECAST_BASE_URL = "https://raw.githubusercontent.com/majito0703/measure_data_logger/main/pronosticos/";
let forecastData = {};
let forecastChart = null;
let currentForecastVariable = 'temperature';
let forecastUpdateInterval = null;

// Función para obtener nombre de archivo correcto
function getForecastFileName(variable) {
  const fileMap = {
    'temperature': 'pronostico_temperature.json',
    'humidity': 'pronostico_humidity.json',
    'pm2.5': 'pronostico_pm_2.5.json',
    'pm10': 'pronostico_pm_10.json'
  };
  
  return fileMap[variable] || `pronostico_${variable}.json`;
}

// Mostrar modo pronósticos
function showForecastMode() {
  document.getElementById('forecastChartContainer').style.display = 'block';
  document.getElementById('modelParamsCard').style.display = 'block';
  document.getElementById('mainChartCard').style.display = 'none';
  document.getElementById('variableSelector').style.display = 'none';
  document.getElementById('hourlyForecastContainer').style.display = 'none';
  
  loadAllForecasts();
  
  // Iniciar actualización automática cada 5 minutos
  if (forecastUpdateInterval) {
    clearInterval(forecastUpdateInterval);
  }
  forecastUpdateInterval = setInterval(loadAllForecasts, 5 * 60 * 1000);
}

// Ocultar modo pronósticos
function hideForecastMode() {
  document.getElementById('forecastChartContainer').style.display = 'none';
  document.getElementById('modelParamsCard').style.display = 'none';
  document.getElementById('mainChartCard').style.display = 'block';
  document.getElementById('variableSelector').style.display = 'flex';
  
  // Volver a mostrar pronósticos por hora
  loadHourlyForecast();
  
  // Detener actualización automática
  if (forecastUpdateInterval) {
    clearInterval(forecastUpdateInterval);
    forecastUpdateInterval = null;
  }
}

// Cargar todos los pronósticos
async function loadAllForecasts() {
  try {
    // Mostrar loading
    document.getElementById('forecastLoading').style.display = 'inline-block';
    document.getElementById('forecastInfo').textContent = 'Cargando pronósticos...';
    
    // Limpiar datos previos
    forecastData = {};
    
    // Cargar todas las variables
    const variables = ['temperature', 'humidity', 'pm2.5', 'pm10'];
    const promises = variables.map(variable => loadForecastData(variable));
    
    // Esperar a que todas se carguen
    await Promise.allSettled(promises);
    
    // Ocultar loading
    document.getElementById('forecastLoading').style.display = 'none';
    
    // Mostrar mensaje
    const loadedCount = Object.keys(forecastData).filter(key => forecastData[key]).length;
    document.getElementById('forecastInfo').textContent = 
      `Cargados ${loadedCount} de 4 pronósticos`;
    
    // Si se cargó temperatura, mostrarla
    if (forecastData['temperature']) {
      updateForecastChart();
      updateModelParams();
      updateQuickStats();
    }
    
  } catch (error) {
    console.error('Error cargando pronósticos:', error);
    document.getElementById('forecastLoading').style.display = 'none';
    document.getElementById('forecastInfo').textContent = 'Error al cargar pronósticos';
  }
}

// Cargar datos de pronóstico específico
async function loadForecastData(variable) {
  try {
    const fileName = getForecastFileName(variable);
    
    const response = await fetch(`${FORECAST_BASE_URL}${fileName}?t=${Date.now()}`);
    
    if (!response.ok) {
      throw new Error(`Error ${response.status}: ${response.statusText}`);
    }
    
    const data = await response.json();
    
    // Procesar datos
    const processedData = {
      ...data,
      variable: variable,
      // Asegurar arrays
      historico: Array.isArray(data.historico) ? data.historico : [],
      pronosticos: Array.isArray(data.pronosticos) ? data.pronosticos : []
    };
    
    // Guardar datos
    forecastData[variable] = processedData;
    
    // Marcar pestaña como cargada
    updateTabStatus(variable, 'loaded');
    
    return processedData;
    
  } catch (error) {
    console.error(`Error cargando pronóstico para ${variable}:`, error);
    updateTabStatus(variable, 'error');
    return null;
  }
}

// Actualizar estado de la pestaña
function updateTabStatus(variable, status) {
  const tab = document.querySelector(`.forecast-tab[data-variable="${variable}"]`);
  if (!tab) return;
  
  tab.classList.remove('loaded', 'error', 'active');
  
  if (status === 'loaded') {
    tab.classList.add('loaded');
  } else if (status === 'error') {
    tab.classList.add('error');
  }
  
  if (variable === currentForecastVariable) {
    tab.classList.add('active');
  }
}

// FUNCIÓN MEJORADA: Actualizar gráfica de pronóstico
function updateForecastChart() {
  const data = forecastData[currentForecastVariable];
  if (!data) {
    console.error('No hay datos para:', currentForecastVariable);
    document.getElementById('forecastInfo').textContent = 'Error: No hay datos para esta variable';
    return;
  }
  
  const ctx = document.getElementById('forecastChart').getContext('2d');
  
  // Destruir gráfica anterior si existe
  if (forecastChart) {
    forecastChart.destroy();
  }
  
  // Verificar que haya datos suficientes
  if (data.historico.length === 0 || data.pronosticos.length === 0) {
    document.getElementById('forecastInfo').textContent = 
      `Error: Datos insuficientes (históricos: ${data.historico.length}, pronósticos: ${data.pronosticos.length})`;
    return;
  }
  
  // Preparar datos combinados para una línea continua
  const allDates = [];
  const allData = [];
  const datasetTypes = []; // Para identificar tipo de dato
  
  // Agregar datos históricos
  data.historico.forEach((item, index) => {
    try {
      const date = new Date(item.fecha);
      if (!isNaN(date.getTime())) {
        allDates.push(date);
        allData.push(parseFloat(item.valor) || 0);
        datasetTypes.push('historical');
      }
    } catch (e) {
      console.warn('Fecha histórica inválida:', item.fecha);
    }
  });
  
  // Agregar datos de pronóstico
  const forecastStartDate = new Date(data.pronosticos[0].fecha);
  const lastHistoricalDate = allDates[allDates.length - 1];
  
  // Asegurar continuidad entre histórico y pronóstico
  if (lastHistoricalDate && forecastStartDate) {
    // Agregar un punto de transición
    allDates.push(forecastStartDate);
    allData.push(allData[allData.length - 1]); // Último valor histórico
    datasetTypes.push('transition');
  }
  
  data.pronosticos.forEach((item, index) => {
    try {
      const date = new Date(item.fecha);
      if (!isNaN(date.getTime())) {
        allDates.push(date);
        allData.push(parseFloat(item.pronostico) || 0);
        datasetTypes.push('forecast');
      }
    } catch (e) {
      console.warn('Fecha de pronóstico inválida:', item.fecha);
    }
  });
  
  // Preparar intervalos de confianza
  const conf80Lower = [];
  const conf80Upper = [];
  const conf95Lower = [];
  const conf95Upper = [];
  
  data.pronosticos.forEach(item => {
    conf80Lower.push(parseFloat(item.confianza_80_min) || 0);
    conf80Upper.push(parseFloat(item.confianza_80_max) || 0);
    conf95Lower.push(parseFloat(item.confianza_95_min) || 0);
    conf95Upper.push(parseFloat(item.confianza_95_max) || 0);
  });
  
  // Obtener fechas de pronóstico
  const forecastDates = data.pronosticos.map(item => {
    try {
      return new Date(item.fecha);
    } catch (e) {
      return new Date();
    }
  });
  
  // Crear datasets
  const datasets = [];
  
  // 1. Línea principal combinada (histórico + pronóstico)
  datasets.push({
    label: 'Datos',
    data: allDates.map((date, i) => ({x: date, y: allData[i]})),
    borderColor: (context) => {
      const index = context.dataIndex;
      return datasetTypes[index] === 'historical' ? 'black' : 'red';
    },
    backgroundColor: 'transparent',
    borderWidth: 2,
    tension: 0.2,
    pointRadius: 0,
    segment: {
      borderColor: ctx => {
        const index = ctx.p0DataIndex;
        return datasetTypes[index] === 'historical' ? 'black' : 'red';
      }
    }
  });
  
  // 2. Intervalo de confianza 95%
  if (conf95Lower.length > 0 && conf95Upper.length > 0) {
    datasets.push({
      label: 'Confianza 95%',
      data: forecastDates.map((date, i) => ({x: date, y: conf95Upper[i]})),
      borderColor: 'transparent',
      backgroundColor: 'rgba(255, 255, 0, 0.2)',
      fill: {
        target: '-1',
        above: 'rgba(255, 255, 0, 0.2)'
      },
      pointRadius: 0,
      borderWidth: 0
    });
    
    datasets.push({
      label: '_conf95_lower',
      data: forecastDates.map((date, i) => ({x: date, y: conf95Lower[i]})),
      borderColor: 'transparent',
      backgroundColor: 'rgba(255, 255, 0, 0.2)',
      pointRadius: 0,
      borderWidth: 0
    });
  }
  
  // 3. Intervalo de confianza 80%
  if (conf80Lower.length > 0 && conf80Upper.length > 0) {
    datasets.push({
      label: 'Confianza 80%',
      data: forecastDates.map((date, i) => ({x: date, y: conf80Upper[i]})),
      borderColor: 'transparent',
      backgroundColor: 'rgba(0, 255, 0, 0.2)',
      fill: {
        target: '-1',
        above: 'rgba(0, 255, 0, 0.2)'
      },
      pointRadius: 0,
      borderWidth: 0
    });
    
    datasets.push({
      label: '_conf80_lower',
      data: forecastDates.map((date, i) => ({x: date, y: conf80Lower[i]})),
      borderColor: 'transparent',
      backgroundColor: 'rgba(0, 255, 0, 0.2)',
      pointRadius: 0,
      borderWidth: 0
    });
  }
  
  // 4. Línea de límite permitido si existe
  if (data.limite_permitido !== null && data.limite_permitido > 0) {
    datasets.push({
      label: 'Límite Permitido',
      data: [
        {x: allDates[0], y: data.limite_permitido},
        {x: allDates[allDates.length - 1], y: data.limite_permitido}
      ],
      borderColor: 'blue',
      backgroundColor: 'blue',
      borderWidth: 1,
      borderDash: [5, 5],
      pointRadius: 0,
      fill: false
    });
  }
  
  // Configurar tooltip mejorado
  const tooltipCallbacks = {
    title: function(tooltipItems) {
      if (tooltipItems.length > 0) {
        const date = new Date(tooltipItems[0].parsed.x);
        return date.toLocaleString('es-ES', {
          day: '2-digit',
          month: '2-digit',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
      }
      return '';
    },
    label: function(context) {
      const datasetLabel = context.dataset.label || '';
      const value = context.parsed.y;
      
      // Para la línea principal
      if (datasetLabel === 'Datos') {
        const index = context.dataIndex;
        const dataType = datasetTypes[index];
        const labelText = dataType === 'historical' ? 'Histórico' : 'Pronóstico';
        return `${labelText}: ${value.toFixed(2)}`;
      }
      
      // Para límite permitido
      if (datasetLabel === 'Límite Permitido') {
        return `Límite: ${value.toFixed(2)}`;
      }
      
      // No mostrar etiquetas para intervalos de confianza
      if (datasetLabel.includes('Confianza') || datasetLabel.startsWith('_')) {
        return null;
      }
      
      return `${datasetLabel}: ${value.toFixed(2)}`;
    },
    afterLabel: function(context) {
      const datasetLabel = context.dataset.label || '';
      
      // Mostrar información de confianza en tooltip
      if (datasetLabel === 'Datos') {
        const index = context.dataIndex;
        if (datasetTypes[index] === 'forecast') {
          const forecastIndex = index - data.historico.length - 1;
          if (forecastIndex >= 0 && forecastIndex < data.pronosticos.length) {
            const item = data.pronosticos[forecastIndex];
            const lines = [];
            
            if (item.confianza_80_min && item.confianza_80_max) {
              lines.push(`80%: [${parseFloat(item.confianza_80_min).toFixed(2)}, ${parseFloat(item.confianza_80_max).toFixed(2)}]`);
            }
            
            if (item.confianza_95_min && item.confianza_95_max) {
              lines.push(`95%: [${parseFloat(item.confianza_95_min).toFixed(2)}, ${parseFloat(item.confianza_95_max).toFixed(2)}]`);
            }
            
            return lines.join('\n');
          }
        }
      }
      return null;
    },
    // Filtrar qué datasets se muestran en el tooltip
    filter: function(tooltipItem) {
      const label = tooltipItem.dataset.label || '';
      return label === 'Datos' || label === 'Límite Permitido';
    }
  };
  
  // Crear gráfica
  forecastChart = new Chart(ctx, {
    type: 'line',
    data: { datasets },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { 
          display: false 
        },
        tooltip: {
          mode: 'index',
          intersect: false,
          callbacks: tooltipCallbacks,
          backgroundColor: 'rgba(0, 0, 0, 0.8)',
          titleColor: '#fff',
          bodyColor: '#fff',
          borderColor: 'var(--ucc-verde)',
          borderWidth: 1,
          padding: 10,
          displayColors: false,
          usePointStyle: true
        }
      },
      scales: {
        x: {
          type: 'time',
          time: {
            unit: 'day',
            displayFormats: {
              hour: 'dd/MM HH:mm',
              day: 'dd/MM',
              week: 'dd/MM',
              month: 'MM/yyyy'
            },
            tooltipFormat: 'dd/MM/yyyy HH:mm'
          },
          title: { 
            display: true, 
            text: 'Fecha',
            color: '#666',
            font: {
              size: 12
            }
          },
          grid: {
            color: 'rgba(0,0,0,0.1)'
          },
          ticks: {
            maxRotation: 45,
            minRotation: 45,
            font: {
              size: 10
            }
          }
        },
        y: {
          beginAtZero: currentForecastVariable.includes('pm'),
          title: {
            display: true,
            text: getVariableDisplayName(currentForecastVariable),
            color: '#666',
            font: {
              size: 12
            }
          },
          grid: {
            color: 'rgba(0,0,0,0.1)'
          }
        }
      },
      interaction: {
        mode: 'index',
        intersect: false,
        axis: 'x'
      },
      hover: {
        mode: 'index',
        intersect: false
      }
    }
  });
  
  // Actualizar información
  document.getElementById('forecastTitle').textContent = 
    `Pronóstico - ${getVariableDisplayName(currentForecastVariable)}`;
  
  document.getElementById('forecastInfo').innerHTML = `
    <strong>${data.modelo || 'SARIMA'}</strong> | 
    AIC: ${data.aic ? data.aic.toFixed(2) : 'N/A'} | 
    Pronóstico: ${data.pronosticos.length} horas | 
    Actualizado: ${new Date().toLocaleString()}
  `;
  
  // Actualizar estadísticas rápidas (la tabla se ha eliminado)
  updateQuickStats();
  
  document.getElementById('forecastChart').style.height = '300px';
}

// Actualizar estadísticas rápidas (se mantiene esta sección)
function updateQuickStats() {
  const data = forecastData[currentForecastVariable];
  if (!data) return;
  
  const statsContainer = document.getElementById('quickStats');
  if (!statsContainer) return;
  
  const unidad = getUnit(currentForecastVariable);
  
  // Calcular estadísticas
  const valoresPronostico = data.pronosticos.map(p => parseFloat(p.pronostico)).filter(v => !isNaN(v));
  const min = valoresPronostico.length > 0 ? Math.min(...valoresPronostico) : 0;
  const max = valoresPronostico.length > 0 ? Math.max(...valoresPronostico) : 0;
  const avg = valoresPronostico.length > 0 ? valoresPronostico.reduce((a, b) => a + b, 0) / valoresPronostico.length : 0;
  
  statsContainer.innerHTML = `
    <div class="stat-card">
      <div class="stat-title">Mínimo pronosticado</div>
      <div class="stat-value">${min.toFixed(2)} ${unidad}</div>
      <div class="stat-subtitle">Valor más bajo esperado</div>
    </div>
    <div class="stat-card">
      <div class="stat-title">Máximo pronosticado</div>
      <div class="stat-value">${max.toFixed(2)} ${unidad}</div>
      <div class="stat-subtitle">Valor más alto esperado</div>
    </div>
    <div class="stat-card">
      <div class="stat-title">Promedio</div>
      <div class="stat-value">${avg.toFixed(2)} ${unidad}</div>
      <div class="stat-subtitle">Media de los pronósticos</div>
    </div>
    <div class="stat-card">
      <div class="stat-title">Horas pronosticadas</div>
      <div class="stat-value">${valoresPronostico.length}</div>
      <div class="stat-subtitle">Total de horas</div>
    </div>
  `;
  
  statsContainer.style.display = 'flex';
}

// Actualizar parámetros del modelo
function updateModelParams() {
  const data = forecastData[currentForecastVariable];
  if (!data) return;
  
  const paramsGrid = document.getElementById('paramsGrid');
  const modelInfo = document.getElementById('modelInfo');
  
  if (!paramsGrid || !modelInfo) return;
  
  // Información general
  modelInfo.innerHTML = `
    <strong>${getVariableDisplayName(currentForecastVariable)}</strong> | 
    Modelo: ${data.modelo || 'SARIMA'} | 
    AIC: ${data.aic ? data.aic.toFixed(2) : 'N/A'} | 
    Observaciones: ${data.historico.length}
  `;
  
  // Crear contenido de parámetros
  let paramsHTML = `
    <div class="param-group">
      <div class="param-title">Información del Modelo</div>
      <div class="param-item">
        <span class="param-label">Variable:</span>
        <span class="param-value">${getVariableDisplayName(currentForecastVariable)}</span>
      </div>
      <div class="param-item">
        <span class="param-label">Modelo SARIMA:</span>
        <span class="param-value">${data.modelo || 'SARIMA'}</span>
      </div>
      <div class="param-item">
        <span class="param-label">Criterio de Akaike (AIC):</span>
        <span class="param-value">${data.aic ? data.aic.toFixed(2) : 'N/A'}</span>
      </div>
      <div class="param-item">
        <span class="param-label">Horas de pronóstico:</span>
        <span class="param-value">${data.pronosticos.length}</span>
      </div>
    </div>
    
    <div class="param-group">
      <div class="param-title">Parámetros Estadísticos</div>
      <div class="param-item">
        <span class="param-label">Datos históricos:</span>
        <span class="param-value">${data.historico.length}</span>
      </div>
      <div class="param-item">
        <span class="param-label">Período pronosticado:</span>
        <span class="param-value">${data.pronosticos.length} horas</span>
      </div>
      ${data.limite_permitido ? `
      <div class="param-item">
        <span class="param-label">Límite permitido:</span>
        <span class="param-value">${data.limite_permitido} ${getUnit(currentForecastVariable)}</span>
      </div>
      ` : ''}
    </div>
    
    <div class="param-group" style="grid-column: 1 / -1;">
      <div class="param-title">Ecuación del Modelo SARIMA</div>
      <div class="equation-box" id="equationBox">
        ${data.modelo || 'Modelo SARIMA personalizado'}
      </div>
    </div>
  `;
  
  paramsGrid.innerHTML = paramsHTML;
}

// Funciones auxiliares
function getVariableDisplayName(variable) {
  const names = {
    'temperature': 'Temperatura (°C)',
    'humidity': 'Humedad (%)',
    'pm2.5': 'PM2.5 (µg/m³)',
    'pm10': 'PM10 (µg/m³)'
  };
  return names[variable] || variable;
}

function getUnit(variable) {
  const units = {
    'temperature': '°C',
    'humidity': '%',
    'pm2.5': 'µg/m³',
    'pm10': 'µg/m³'
  };
  return units[variable] || '';
}

// Configurar pestañas de pronóstico
function setupForecastTabs() {
  document.querySelectorAll('.forecast-tab').forEach(tab => {
    tab.addEventListener('click', function() {
      // Quitar active de todas
      document.querySelectorAll('.forecast-tab').forEach(t => {
        t.classList.remove('active');
      });
      
      // Activar esta
      this.classList.add('active');
      
      // Cambiar variable
      currentForecastVariable = this.dataset.variable;
      
      // Actualizar gráfica si hay datos
      if (forecastData[currentForecastVariable]) {
        updateForecastChart();
        updateModelParams();
        updateQuickStats();
      } else {
        // Cargar datos
        loadForecastData(currentForecastVariable).then(() => {
          if (forecastData[currentForecastVariable]) {
            updateForecastChart();
            updateModelParams();
            updateQuickStats();
          }
        });
      }
    });
  });
}

/* ---------- polling (cada 30s) ---------- */
loadData();
setInterval(loadData, 30000);

/* ---------- inicializar pestañas de pronóstico ---------- */
setupForecastTabs();
</script>
</body>
</html>
