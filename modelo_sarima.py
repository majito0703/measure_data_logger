# -*- coding: utf-8 -*-
"""Modelo_Sarima.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iAFMXztN6AvkjVaC3_b2wtbi-jGTxS8R
"""

!python3 -m pip install --upgrade pip >& /dev/null
!python3 -m pip install --upgrade direl_ts_tool_kit >& /dev/null
!python3 -m pip install jupyter-black >& /dev/null

import jupyter_black

jupyter_black.load()

import warnings
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from statsmodels.tsa.statespace.sarimax import SARIMAX
import matplotlib.dates as mdates

from datetime import timedelta
from direl_ts_tool_kit import (
    parse_datetime_index,
    plot_time_series,
    save_figure,
    plot_histogram,
    reindex_and_aggregate,
)

from google.colab import files

warnings.filterwarnings("ignore")

uploaded = files.upload()

# Cargar datos
df0 = pd.read_csv("/content/DTH_22_N - Hoja 1.csv")
df0.head(2)

df0.rename(
    columns={
        "Date": "date",
        "PM 1.0 (µg/m³)": "PM 1",
        "PM 2.5(µg/m³)": "PM 2.5",
        "PM 10 (µg/m³)": "PM 10",
    },
    inplace=True,
)

df0["Temperature"] = pd.to_numeric(df0["Temperature"], errors="coerce")
df0["Humidity"] = pd.to_numeric(df0["Humidity"], errors="coerce")
df0["PM 2.5"] = pd.to_numeric(df0["PM 2.5"], errors="coerce")
df0["PM 10"] = pd.to_numeric(df0["PM 10"], errors="coerce")

df1 = parse_datetime_index(df0, format="%d/%m/%Y %H:%M:%S")
df1.head(10)

df1 = df1.resample("10min").mean()
df1.describe().transpose()

fig = plot_time_series(
    df1, variable="Temperature", units="$(^\circ C)$", time_unit="Day"
)
fig.show()

fig = plot_time_series(df1, variable="Humidity", units="$(\%)$", time_unit="Day")
fig.show()

fig = plot_time_series(df1, variable="PM 10", units="$(\mu g/m^{3})$", time_unit="Day")
fig.show()

fig = plot_time_series(df1, variable="PM 2.5", units="$(\mu g/m^{3})$", time_unit="Day")
fig.show()

df2 = df1.copy()

vars_to_impute = ["Temperature", "Humidity", "PM 10", "PM 2.5"]

for var in vars_to_impute:
    # Marcar NaN antes de imputar
    df2[f"{var}_imputed"] = df2[var].isna()

    # Calcular medias por hora:minuto
    means = df2.groupby(df2.index.time)[var].transform("mean")

    # Llenar SOLO los NaN, sin alterar valores originales
    df2[var] = df2[var].fillna(means)

df2 = df2.loc[:, ~df2.columns.str.endswith("_imputed")]
# Ver primeras filas del nuevo DataFrame
print(df2.head())

# Ver solo los datos imputados de cada variable
print(df2[[col for col in df2.columns if "imputed" in col]].sum())
df2 = df2.loc[:, ~df2.columns.str.endswith("_imputed")]

# COMPROBAR LA IMPUTACION DE LOS DATOS
fig = plot_time_series(
    df2, variable="Temperature", units="$(^\circ C)$", time_unit="Day"
)
fig.show()

fig = plot_time_series(df2, variable="Humidity", units="$(\%)$", time_unit="Day")
fig.show()

fig = plot_time_series(df2, variable="PM 10", units="$(\mu g/m^{3})$", time_unit="Day")
fig.show()

fig = plot_time_series(df2, variable="PM 2.5", units="$(\mu g/m^{3})$", time_unit="Day")
fig.show()

df3 = df2.copy()
# Eliminar los días 24 y 25
df3 = df3[~df3.index.day.isin([24, 25])]
df3 = df3.drop(columns=["PM 1"])
# Verificar los primeros registros
print(df3.head())

# Verificar los últimos registros para asegurarte que se eliminaron los días 19 y 20
print(df3.tail())

# ======================================================
# 1. RESAMPLEO A DATOS POR HORA
# ======================================================
df_hourly = df3.resample("H").mean().dropna()

variables = ["Temperature", "Humidity", "PM 2.5", "PM 10"]

# ======================================================
# 2. OPTIMIZADOR SARIMA (SIN PMDARIMA)
# ======================================================
p = d = q = [0, 1]
P = D = Q = [0, 1]
m = 12  # estacionalidad de 12 horas


def buscar_mejor_modelo(series):
    mejor_aic = float("inf")
    mejor_modelo = None
    mejor_orden = None
    mejor_orden_season = None
    mejores_parametros = None
    mejor_summary = None

    for pi in p:
        for di in d:
            for qi in q:
                for Pi in P:
                    for Di in D:
                        for Qi in Q:
                            orden = (pi, di, qi)
                            orden_seas = (Pi, Di, Qi, m)

                            try:
                                modelo = SARIMAX(
                                    series,
                                    order=orden,
                                    seasonal_order=orden_seas,
                                    enforce_stationarity=False,
                                    enforce_invertibility=False,
                                ).fit(disp=False, maxiter=200)

                                if modelo.aic < mejor_aic:
                                    mejor_aic = modelo.aic
                                    mejor_modelo = modelo
                                    mejor_orden = orden
                                    mejor_orden_season = orden_seas
                                    mejores_parametros = modelo.params
                                    mejor_summary = modelo.summary()

                            except:
                                continue

    return (
        mejor_modelo,
        mejor_orden,
        mejor_orden_season,
        mejor_aic,
        mejores_parametros,
        mejor_summary,
    )

# ======================================================
# 3. FUNCIÓN PARA OBTENER ECUACIÓN MATEMÁTICA
# ======================================================
def obtener_ecuacion_sarima(modelo, orden, orden_seas):
    """
    Genera la ecuación matemática del modelo SARIMA
    """
    p, d, q = orden
    P, D, Q, m = orden_seas

    # Obtener parámetros
    params = modelo.params

    # Inicializar partes de la ecuación
    parte_ar = ""
    parte_ma = ""
    parte_sar = ""
    parte_sma = ""

    # Coeficientes AR (no estacional)
    for i in range(1, p + 1):
        if f"ar.L{i}" in params:
            coef = params[f"ar.L{i}"]
            parte_ar += f" + {coef:.4f}·y_t-{i}"

    # Coeficientes MA (no estacional)
    for i in range(1, q + 1):
        if f"ma.L{i}" in params:
            coef = params[f"ma.L{i}"]
            parte_ma += f" + {coef:.4f}·ε_t-{i}"

    # Coeficientes SAR (estacional)
    for i in range(1, P + 1):
        if f"ar.S.L{m*i}" in params:
            coef = params[f"ar.S.L{m*i}"]
            parte_sar += f" + {coef:.4f}·y_t-{m*i}"

    # Coeficientes SMA (estacional)
    for i in range(1, Q + 1):
        if f"ma.S.L{m*i}" in params:
            coef = params[f"ma.S.L{m*i}"]
            parte_sma += f" + {coef:.4f}·ε_t-{m*i}"

    # Constante
    constante = ""
    if "intercept" in params:
        constante = f"{params['intercept']:.4f} + "
    elif "const" in params:
        constante = f"{params['const']:.4f} + "

    # Construir ecuación
    if d == 0 and D == 0:
        ecuacion = f"y_t = {constante}"
    else:
        # Para modelos con diferenciación
        ecuacion = "Δ^d Δ_s^D y_t = "
        if constante.strip():
            ecuacion = f"Δ^d Δ_s^D y_t = {constante}"

    # Agregar partes
    if parte_ar:
        ecuacion += parte_ar[3:] if ecuacion.endswith("= ") else parte_ar
    if parte_ma:
        ecuacion += parte_ma
    if parte_sar:
        ecuacion += parte_sar
    if parte_sma:
        ecuacion += parte_sma

    if parte_ar or parte_ma or parte_sar or parte_sma:
        ecuacion += " + ε_t"
    else:
        ecuacion += "ε_t"

    return ecuacion

# ======================================================
# 4. FUNCIÓN PARA MOSTRAR PARÁMETROS COMO EN LA IMAGEN
# ======================================================
def mostrar_parametros_tabla(modelo, orden, orden_seas, aic):
    """
    Muestra los parámetros en formato de tabla como en la imagen
    """
    params = modelo.params
    p, d, q = orden
    P, D, Q, m = orden_seas

    print("\n" + "=" * 60)
    print("PARÁMETROS DEL MODELO SARIMA")
    print("=" * 60)

    # Crear lista de parámetros
    parametros_lista = []

    # Parámetros AR
    for i in range(1, p + 1):
        key = f"ar.L{i}"
        if key in params:
            parametros_lista.append((f"φ_{i}", params[key], modelo.bse.get(key, "N/A")))

    # Parámetros MA
    for i in range(1, q + 1):
        key = f"ma.L{i}"
        if key in params:
            parametros_lista.append((f"θ_{i}", params[key], modelo.bse.get(key, "N/A")))

    # Parámetros SAR
    for i in range(1, P + 1):
        key = f"ar.S.L{m*i}"
        if key in params:
            parametros_lista.append((f"Φ_{i}", params[key], modelo.bse.get(key, "N/A")))

    # Parámetros SMA
    for i in range(1, Q + 1):
        key = f"ma.S.L{m*i}"
        if key in params:
            parametros_lista.append((f"Θ_{i}", params[key], modelo.bse.get(key, "N/A")))

    # Constante
    if "intercept" in params:
        parametros_lista.append(
            ("intercept", params["intercept"], modelo.bse.get("intercept", "N/A"))
        )
    elif "const" in params:
        parametros_lista.append(
            ("const", params["const"], modelo.bse.get("const", "N/A"))
        )

    # Varianza del error
    if "sigma2" in params:
        parametros_lista.append(
            ("σ²", params["sigma2"], modelo.bse.get("sigma2", "N/A"))
        )

    # Mostrar tabla
    print(f"\nOrden: SARIMA{orden}{orden_seas}")
    print(f"AIC: {aic:.2f}")
    print("\n" + "-" * 60)
    print(f"{'Parámetro':<15} {'Valor':<15} {'Error estándar':<15}")
    print("-" * 60)

    for nombre, valor, error in parametros_lista:
        if isinstance(error, (int, float)):
            print(f"{nombre:<15} {valor:<15.4f} {error:<15.4f}")
        else:
            print(f"{nombre:<15} {valor:<15.4f} {str(error):<15}")

    print("-" * 60)

# ======================================================
# 5. FUNCIÓN PARA GRAFICAR PRONÓSTICO CON FECHAS MEJORADAS
# ======================================================
def graficar_pronostico(modelo, series, pasos=48, limite=None):
    pred = modelo.get_forecast(steps=pasos)
    media = pred.predicted_mean
    conf_80 = pred.conf_int(alpha=0.20)
    conf_95 = pred.conf_int(alpha=0.05)

    # Crear figura con tamaño adecuado
    fig, ax = plt.subplots(figsize=(15, 6))

    # Datos históricos
    ax.plot(series.index, series.values, label="Medido", color="black", linewidth=1.5)

    # Pronóstico
    ax.plot(
        media.index,
        media.values,
        label=f"Pronóstico {series.name}",
        color="red",
        linewidth=2,
    )

    # Bandas de confianza
    ax.fill_between(
        conf_80.index,
        conf_80.iloc[:, 0],
        conf_80.iloc[:, 1],
        color="green",
        alpha=0.3,
        label="Confianza 80%",
    )
    ax.fill_between(
        conf_95.index,
        conf_95.iloc[:, 0],
        conf_95.iloc[:, 1],
        color="yellow",
        alpha=0.2,
        label="Confianza 95%",
    )

    # Línea vertical para separar historial de pronóstico
    ultimo_historial = series.index[-1]
    ax.axvline(x=ultimo_historial, color="gray", linestyle="--", alpha=0.7, linewidth=1)

    # Línea de norma o límite permitido
    if limite is not None:
        ax.axhline(
            y=limite,
            color="blue",
            linestyle="--",
            linewidth=2,
            label="Nivel máximo permitido (24H) en Colombia",
        )

    # Configurar formato de fechas
    # Determinar el rango de fechas
    fecha_min = series.index.min()
    fecha_max = media.index.max()

    # Calcular diferencia de días para determinar el formato
    dias_totales = (fecha_max - fecha_min).days

    if dias_totales <= 7:  # Si es menos de una semana
        # Formato: Día Hora (ej: "11 Nov 10:00")
        ax.xaxis.set_major_formatter(mdates.DateFormatter("%d %b %H:%M"))
        ax.xaxis.set_major_locator(mdates.HourLocator(interval=6))
    elif dias_totales <= 30:  # Si es menos de un mes
        # Formato: Día Mes (ej: "11 Nov")
        ax.xaxis.set_major_formatter(mdates.DateFormatter("%d %b"))
        ax.xaxis.set_major_locator(mdates.DayLocator(interval=2))
    else:  # Si es más de un mes
        # Formato: Mes (ej: "Nov 2025")
        ax.xaxis.set_major_formatter(mdates.DateFormatter("%b %Y"))
        ax.xaxis.set_major_locator(mdates.MonthLocator())

    # Rotar etiquetas para mejor lectura
    plt.setp(ax.xaxis.get_majorticklabels(), rotation=45, ha="right")

    # Agregar leyenda de separación
    ax.text(
        ultimo_historial + timedelta(hours=1),
        ax.get_ylim()[1] * 0.95,
        "Pronóstico",
        fontsize=10,
        color="darkred",
        alpha=0.8,
    )

    # Títulos y etiquetas
    ax.set_title(f"Pronóstico SARIMA - {series.name}", fontsize=14, fontweight="bold")
    ax.set_xlabel("Fecha y Hora", fontsize=12)

    # Etiqueta del eje Y dependiendo de la variable
    if series.name == "Temperature":
        ax.set_ylabel("Temperatura (°C)", fontsize=12)
    elif series.name == "Humidity":
        ax.set_ylabel("Humedad (%)", fontsize=12)
    elif series.name in ["PM 2.5", "PM 10"]:
        ax.set_ylabel(f"{series.name} (µg/m³)", fontsize=12)
    else:
        ax.set_ylabel(series.name, fontsize=12)

    # Cuadrícula
    ax.grid(True, alpha=0.3, linestyle="--")

    # Leyenda
    ax.legend(loc="upper left", fontsize=10)

    # Ajustar márgenes
    plt.tight_layout()

    plt.show()
    # También imprimir fechas importantes
    print(
        f"\nRango de datos históricos: {series.index[0].strftime('%d/%m/%Y %H:%M')} - {series.index[-1].strftime('%d/%m/%Y %H:%M')}"
    )
    print(
        f"Pronóstico desde: {media.index[0].strftime('%d/%m/%Y %H:%M')} hasta {media.index[-1].strftime('%d/%m/%Y %H:%M')}"
    )
    print(f"Duración del pronóstico: {pasos} horas ({pasos/24:.1f} días)")

# ======================================================
# 6. EJECUCIÓN COMPLETA POR VARIABLE
# ======================================================
limites = {
    "Temperature": None,
    "Humidity": None,
    "PM 2.5": 37,  # valor OMS o Colombia
    "PM 10": 75,
}

resultados = {}
ecuaciones = {}
parametros_tablas = {}

for var in variables:
    print(f"\n{'='*80}")
    print(f" OPTIMIZANDO: {var}")
    print(f"{'='*80}")

    serie = df_hourly[var]

    modelo, orden, orden_s, aic, parametros, summary = buscar_mejor_modelo(serie)

    print(f"\nMejor modelo para {var}: SARIMA{orden}{orden_s}")
    print(f"AIC = {aic:.2f}")

    # Obtener y mostrar ecuación matemática
    ecuacion = obtener_ecuacion_sarima(modelo, orden, orden_s)
    print(f"\nEcuación matemática:")
    print(f"{ecuacion}")

    # Mostrar parámetros en formato de tabla
    mostrar_parametros_tabla(modelo, orden, orden_s, aic)

    # Guardar resultados
    resultados[var] = modelo
    ecuaciones[var] = ecuacion
    parametros_tablas[var] = {
        "orden": orden,
        "orden_estacional": orden_s,
        "aic": aic,
        "parametros": parametros,
        "summary": summary,
    }

    # Graficar pronóstico (72 horas adelante)
    graficar_pronostico(modelo, serie, pasos=72, limite=limites[var])

# ======================================================
# 7. RESUMEN FINAL DE TODOS LOS MODELOS
# ======================================================
print(f"\n{'='*80}")
print(" RESUMEN FINAL DE MODELOS SARIMA")
print(f"{'='*80}")

for var in variables:
    print(f"\n{var}:")
    print(f"  Modelo: SARIMA{resultados[var].specification.order}")
    print(f"          {resultados[var].specification.seasonal_order}")
    print(f"  AIC: {resultados[var].aic:.2f}")
    print(f"  Ecuación: {ecuaciones[var]}")
    print(f"  Número de observaciones: {len(df_hourly[var])}")

# ======================================================
# 8. EXPORTAR PRONÓSTICOS A JSON PARA EL DASHBOARD
# ======================================================
def exportar_pronosticos_json(modelo, serie, pasos=72, var_name=""):
    """
    Exporta datos históricos y pronósticos en formato JSON para el dashboard
    """
    # Obtener pronóstico
    pred = modelo.get_forecast(steps=pasos)
    media = pred.predicted_mean
    conf_80 = pred.conf_int(alpha=0.20)
    conf_95 = pred.conf_int(alpha=0.05)

    # Preparar datos históricos
    historico = []
    for fecha, valor in serie.items():
        historico.append(
            {
                "fecha": fecha.strftime("%Y-%m-%d %H:%M:%S"),
                "valor": float(valor) if not pd.isna(valor) else None,
            }
        )

    # Preparar pronósticos
    pronosticos = []
    for i in range(len(media)):
        fecha_str = media.index[i].strftime("%Y-%m-%d %H:%M:%S")
        pronosticos.append(
            {
                "fecha": fecha_str,
                "pronostico": float(media.iloc[i]),
                "confianza_80_min": float(conf_80.iloc[i, 0]),
                "confianza_80_max": float(conf_80.iloc[i, 1]),
                "confianza_95_min": float(conf_95.iloc[i, 0]),
                "confianza_95_max": float(conf_95.iloc[i, 1]),
            }
        )

    # Crear objeto completo
    datos_json = {
        "variable": var_name,
        "fecha_generacion": pd.Timestamp.now().strftime("%Y-%m-%d %H:%M:%S"),
        "modelo": f"SARIMA{modelo.specification.order}{modelo.specification.seasonal_order}",
        "aic": float(modelo.aic),
        "observaciones_historicas": len(serie),
        "horas_pronostico": pasos,
        "limite_permitido": limites.get(var_name),
        "historico": historico[-700:],  # Últimas 100 observaciones
        "pronosticos": pronosticos,
    }

    return datos_json


# ======================================================
# 9. GENERAR Y GUARDAR TODOS LOS JSON
# ======================================================
import json
import os

# Crear directorio para exportar
os.makedirs("pronosticos", exist_ok=True)

# Exportar cada variable
archivos_json = {}

for var in variables:
    print(f"\nExportando {var} a JSON...")

    # Obtener datos JSON
    datos_json = exportar_pronosticos_json(
        modelo=resultados[var], serie=df_hourly[var], pasos=72, var_name=var
    )

    # Nombre del archivo
    nombre_archivo = f"pronosticos/pronostico_{var.lower().replace(' ', '_')}.json"

    # Guardar en archivo
    with open(nombre_archivo, "w", encoding="utf-8") as f:
        json.dump(datos_json, f, indent=2, ensure_ascii=False)

    archivos_json[var] = nombre_archivo
    print(f"✓ Guardado en: {nombre_archivo}")

    # Mostrar vista previa
    print(f"  - Pronósticos generados: {len(datos_json['pronosticos'])}")
    print(f"  - Desde: {datos_json['pronosticos'][0]['fecha']}")
    print(f"  - Hasta: {datos_json['pronosticos'][-1]['fecha']}")

# ======================================================
# 10. CREAR ARCHIVO INDEX CON TODAS LAS VARIABLES
# ======================================================
index_json = {
    "variables_disponibles": variables,
    "fecha_actualizacion": pd.Timestamp.now().strftime("%Y-%m-%d %H:%M:%S"),
    "archivos": {
        var: f"pronostico_{var.lower().replace(' ', '_')}.json" for var in variables
    },
}

with open("pronosticos/index.json", "w", encoding="utf-8") as f:
    json.dump(index_json, f, indent=2, ensure_ascii=False)

print(f"\n{'='*80}")
print(" EXPORTACIÓN COMPLETADA")
print(f"{'='*80}")
print("\nArchivos generados:")
for var, archivo in archivos_json.items():
    print(f"  • {var}: {archivo}")
print(f"  • Índice: pronosticos_json/index.json")