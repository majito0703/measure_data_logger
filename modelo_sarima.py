# -*- coding: utf-8 -*-
"""Modelo_Sarima.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iAFMXztN6AvkjVaC3_b2wtbi-jGTxS8R
"""



# -*- coding: utf-8 -*-
"""Modelo_Sarima.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iAFMXztN6AvkjVaC3_b2wtbi-jGTxS8R
"""

import os
import pickle
import json
import warnings

warnings.filterwarnings("ignore")

# ======================================================
# URL DE GOOGLE SHEETS (definida a nivel global)
# ======================================================
SHEET_URL = "https://docs.google.com/spreadsheets/d/1x1FeUolFWlR07tgrc6F4cgeUhJYV7uQ5yuRTBHO8jWI/edit?gid=0#gid=0"

# ======================================================
# 1. FUNCIÃ“N DE CONEXIÃ“N A GOOGLE SHEETS (COLAB + GITHUB)
# ======================================================


def conectar_a_google_sheets():
    """
    Conecta a Google Sheets de manera inteligente
    - En Colab: usa autenticaciÃ³n normal
    - En GitHub: puede usar Service Account
    """

    try:
        # Verificar si estamos en Google Colab
        try:
            from google.colab import auth

            IN_COLAB = True
        except:
            IN_COLAB = False

        if IN_COLAB:
            # ========== MODO COLAB ==========
            print("ðŸ”‘ Autenticando en Google Colab...")

            # AutenticaciÃ³n interactiva
            auth.authenticate_user()
            from google.auth import default

            creds, _ = default()

            # Guardar credenciales (opcional)
            with open("/content/token.pickle", "wb") as token:
                pickle.dump(creds, token)

            import gspread

            gc = gspread.authorize(creds)

        else:
            # ========== MODO GITHUB/LOCAL ==========
            import gspread

            # Intentar con variable de entorno (para GitHub Actions)
            creds_json = os.getenv("GOOGLE_SHEETS_CREDS")

            if creds_json:
                print("ðŸ”‘ Usando Service Account desde variable de entorno...")
                from google.oauth2.service_account import Credentials

                creds_dict = json.loads(creds_json)
                scope = ["https://www.googleapis.com/auth/spreadsheets"]
                credentials = Credentials.from_service_account_info(
                    creds_dict, scopes=scope
                )
                gc = gspread.authorize(credentials)
            else:
                # Intentar autenticaciÃ³n normal (fallback)
                print("âš ï¸  Intentando autenticaciÃ³n normal...")
                gc = gspread.oauth()  # Esto abrirÃ¡ navegador en local

        # Abrir la hoja
        spreadsheet = gc.open_by_url(SHEET_URL)
        worksheet = spreadsheet.get_worksheet(0)

        print("âœ… ConexiÃ³n exitosa a Google Sheets")
        return worksheet

    except Exception as e:
        print(f"âŒ Error conectando a Google Sheets: {e}")
        print("âš ï¸  Usando datos de ejemplo para continuar...")
        return None


# ======================================================
# 2. CONFIGURACIÃ“N INICIAL DE COLAB
# ======================================================

# Montar Google Drive (solo funciona en Colab)
try:
    from google.colab import drive

    drive.mount("/content/drive", force_remount=False)
    IN_COLAB = True

    # Crear carpeta para pronÃ³sticos
    os.makedirs("/content/drive/MyDrive/pronosticos", exist_ok=True)
    print("âœ… Google Drive montado y carpeta creada")

except:
    IN_COLAB = False
    print("âš ï¸  No es Google Colab, omitiendo montaje de Drive")

# ======================================================
# 3. INSTALAR DEPENDENCIAS (SOLO COLAB)
# ======================================================

if IN_COLAB:
    print("ðŸ“¦ Instalando dependencias en Colab...")
else:
    print("âœ… En GitHub, las dependencias se instalan desde requirements.txt")

# ======================================================
# 4. IMPORTAR BIBLIOTECAS
# ======================================================

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import gspread
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from statsmodels.tsa.statespace.sarimax import SARIMAX
import matplotlib.dates as mdates
from datetime import timedelta

# Cargar jupyter-black (solo Colab)
if IN_COLAB:
    import jupyter_black

    jupyter_black.load()

# ======================================================
# 5. REEMPLAZAR LA IMPORTACIÃ“N DE 'direl_ts_tool_kit'
# ======================================================


def parse_datetime_index(df, date_column="date", format="%d/%m/%Y %H:%M:%S"):
    """
    Convierte una columna de fecha a datetime y la usa como Ã­ndice
    (Reemplaza a la funciÃ³n de direl_ts_tool_kit)
    """
    df_copy = df.copy()
    df_copy[date_column] = pd.to_datetime(
        df_copy[date_column], format=format, errors="coerce"
    )
    df_copy.set_index(date_column, inplace=True)
    return df_copy


def plot_time_series(df, variable, units="", time_unit="Day"):
    """
    Grafica una serie de tiempo
    (VersiÃ³n simplificada de la funciÃ³n original)
    """
    fig, ax = plt.subplots(figsize=(12, 5))

    ax.plot(df.index, df[variable], linewidth=1)
    ax.set_title(f"Serie de Tiempo - {variable}")
    ax.set_xlabel(f"Tiempo ({time_unit})")
    ax.set_ylabel(f"{variable} {units}")
    ax.grid(True, alpha=0.3)

    # Formato de fechas
    ax.xaxis.set_major_formatter(mdates.DateFormatter("%d/%m %H:%M"))
    plt.setp(ax.xaxis.get_majorticklabels(), rotation=45)

    plt.tight_layout()
    return fig


# ======================================================
# 6. CONECTAR Y CARGAR DATOS
# ======================================================

print("\n" + "=" * 60)
print("ðŸ“¥ CARGANDO DATOS DESDE GOOGLE SHEETS")
print("=" * 60)

# Conectar a Google Sheets
worksheet = conectar_a_google_sheets()

if worksheet is not None:
    # Obtener todos los datos
    datos = worksheet.get_all_values()

    # Convertir a DataFrame
    df0 = pd.DataFrame(datos[1:], columns=datos[0])

    print(f"âœ… Datos cargados desde Google Sheets")
    print(f"ðŸ“Š Dimensiones: {df0.shape[0]} filas Ã— {df0.shape[1]} columnas")
    print(f"ðŸ”— URL: {SHEET_URL}")

else:
    # ========== DATOS DE EJEMPLO (si falla la conexiÃ³n) ==========
    print("ðŸ“ Usando datos de ejemplo para demostraciÃ³n...")

    # Crear datos de ejemplo simples
    import numpy as np

    fechas = pd.date_range(start="2024-01-01", periods=100, freq="H")

    datos_ejemplo = {
        "Date": [f.strftime("%d/%m/%Y %H:%M:%S") for f in fechas],
        "Temperature": 25 + 5 * np.sin(np.linspace(0, 10, 100)),
        "Humidity": 60 + 10 * np.cos(np.linspace(0, 8, 100)),
        "PM 2.5(Âµg/mÂ³)": 20 + 8 * np.random.randn(100),
        "PM 10 (Âµg/mÂ³)": 40 + 12 * np.random.randn(100),
        "PM 1.0 (Âµg/mÂ³)": 10 + 4 * np.random.randn(100),
    }

    df0 = pd.DataFrame(datos_ejemplo)
    print(f"ðŸ“Š Datos de ejemplo creados: {df0.shape[0]} filas")

print("\nðŸ“‹ Primeras filas de datos:")
print(df0.head(2))

df0.head(2)

df0.rename(
    columns={
        "Date": "date",
        "PM 1.0 (Âµg/mÂ³)": "PM 1",
        "PM 2.5(Âµg/mÂ³)": "PM 2.5",
        "PM 10 (Âµg/mÂ³)": "PM 10",
    },
    inplace=True,
)

df0["Temperature"] = pd.to_numeric(df0["Temperature"], errors="coerce")
df0["Humidity"] = pd.to_numeric(df0["Humidity"], errors="coerce")
df0["PM 2.5"] = pd.to_numeric(df0["PM 2.5"], errors="coerce")
df0["PM 10"] = pd.to_numeric(df0["PM 10"], errors="coerce")

df1 = parse_datetime_index(df0, format="%d/%m/%Y %H:%M:%S")
df1.head(10)

df1 = parse_datetime_index(df0, format="%d/%m/%Y %H:%M:%S")
df1.head(10)

# ======================================================
# LIMPIAR Y CONVERTIR DATOS ANTES DE RESAMPLE
# ======================================================
print("ðŸ” Verificando tipos de datos antes de resample:")
print(df1.dtypes)

# Identificar columnas que deberÃ­an ser numÃ©ricas
columnas_numericas = ["Temperature", "Humidity", "PM 2.5", "PM 10", "PM 1"]

# Convertir cada columna a numÃ©rico, forzando errores a NaN
for col in columnas_numericas:
    if col in df1.columns:
        print(f"\nConvirtiendo columna '{col}'...")

        # Guardar valores originales para comparar
        valores_originales = df1[col].head(5).tolist()

        # Convertir a numÃ©rico
        df1[col] = pd.to_numeric(df1[col], errors="coerce")

        # Contar valores convertidos y no convertidos
        total_valores = len(df1[col])
        valores_nan = df1[col].isna().sum()
        valores_convertidos = total_valores - valores_nan

        print(f"  Valores originales (primeros 5): {valores_originales}")
        print(f"  Valores convertidos: {valores_convertidos}/{total_valores}")
        print(f"  Valores no convertidos (NaN): {valores_nan}")

        # Mostrar ejemplos de valores no convertidos
        if valores_nan > 0:
            valores_problematicos = df0.loc[df1[col].isna(), col].unique()[:5]
            print(f"  Valores problemÃ¡ticos encontrados: {valores_problematicos}")

# Verificar tipos despuÃ©s de la conversiÃ³n
print("\nâœ… Tipos de datos despuÃ©s de la conversiÃ³n:")
print(df1.dtypes)

# Ahora sÃ­ hacer el resample
print("\nðŸ“Š Realizando resample a 10 minutos...")
df1 = df1.resample("10min").mean()

print("âœ… Resample completado exitosamente")
print(f"ðŸ“Š Nueva forma: {df1.shape[0]} filas Ã— {df1.shape[1]} columnas")

# Mostrar estadÃ­sticas
print("\nðŸ“ˆ EstadÃ­sticas descriptivas:")
print(df1.describe().transpose())

fig = plot_time_series(df1, variable="Temperature", units="Â°C", time_unit="Day")
plt.show()

fig = plot_time_series(df1, variable="Humidity", units="%", time_unit="Day")
plt.show()

fig = plot_time_series(df1, variable="PM 10", units="Âµg/mÂ³", time_unit="Day")
plt.show()

fig = plot_time_series(df1, variable="PM 2.5", units="Âµg/mÂ³", time_unit="Day")
plt.show()

df2 = df1.copy()

vars_to_impute = ["Temperature", "Humidity", "PM 10", "PM 2.5"]

for var in vars_to_impute:
    # Marcar NaN antes de imputar
    df2[f"{var}_imputed"] = df2[var].isna()

    # Calcular medias por hora:minuto
    means = df2.groupby(df2.index.time)[var].transform("mean")

    # Llenar SOLO los NaN, sin alterar valores originales
    df2[var] = df2[var].fillna(means)

df2 = df2.loc[:, ~df2.columns.str.endswith("_imputed")]
# Ver primeras filas del nuevo DataFrame
print(df2.head())

# Ver solo los datos imputados de cada variable
print(df2[[col for col in df2.columns if "imputed" in col]].sum())
df2 = df2.loc[:, ~df2.columns.str.endswith("_imputed")]

fig = plot_time_series(df2, variable="Temperature", units="Â°C", time_unit="Day")
plt.show()

fig = plot_time_series(df2, variable="Humidity", units="%", time_unit="Day")
plt.show()

fig = plot_time_series(df2, variable="PM 10", units="Âµg/mÂ³", time_unit="Day")
plt.show()

fig = plot_time_series(df2, variable="PM 2.5", units="Âµg/mÂ³", time_unit="Day")
plt.show()

df3 = df2.copy()
# Eliminar los dÃ­as 24 y 25
df3 = df3[~df3.index.day.isin([24, 25])]
df3 = df3.drop(columns=["PM 1"])
# Verificar los primeros registros
print(df3.head())

# Verificar los Ãºltimos registros para asegurarte que se eliminaron los dÃ­as 19 y 20
print(df3.tail())

# ======================================================
# 1. RESAMPLEO A DATOS POR HORA
# ======================================================
df_hourly = df3.resample("H").mean().dropna()

variables = ["Temperature", "Humidity", "PM 2.5", "PM 10"]

# ======================================================
# 2. OPTIMIZADOR SARIMA (SIN PMDARIMA)
# ======================================================
p = d = q = [0, 1]
P = D = Q = [0, 1]
m = 12  # estacionalidad de 12 horas


def buscar_mejor_modelo(series):
    mejor_aic = float("inf")
    mejor_modelo = None
    mejor_orden = None
    mejor_orden_season = None
    mejores_parametros = None
    mejor_summary = None

    for pi in p:
        for di in d:
            for qi in q:
                for Pi in P:
                    for Di in D:
                        for Qi in Q:
                            orden = (pi, di, qi)
                            orden_seas = (Pi, Di, Qi, m)

                            try:
                                modelo = SARIMAX(
                                    series,
                                    order=orden,
                                    seasonal_order=orden_seas,
                                    enforce_stationarity=False,
                                    enforce_invertibility=False,
                                ).fit(disp=False, maxiter=200)

                                if modelo.aic < mejor_aic:
                                    mejor_aic = modelo.aic
                                    mejor_modelo = modelo
                                    mejor_orden = orden
                                    mejor_orden_season = orden_seas
                                    mejores_parametros = modelo.params
                                    mejor_summary = modelo.summary()

                            except:
                                continue

    return (
        mejor_modelo,
        mejor_orden,
        mejor_orden_season,
        mejor_aic,
        mejores_parametros,
        mejor_summary,
    )

# ======================================================
# 3. FUNCIÃ“N PARA OBTENER ECUACIÃ“N MATEMÃTICA
# ======================================================
def obtener_ecuacion_sarima(modelo, orden, orden_seas):
    """
    Genera la ecuaciÃ³n matemÃ¡tica del modelo SARIMA
    """
    p, d, q = orden
    P, D, Q, m = orden_seas

    # Obtener parÃ¡metros
    params = modelo.params

    # Inicializar partes de la ecuaciÃ³n
    parte_ar = ""
    parte_ma = ""
    parte_sar = ""
    parte_sma = ""

    # Coeficientes AR (no estacional)
    for i in range(1, p + 1):
        if f"ar.L{i}" in params:
            coef = params[f"ar.L{i}"]
            parte_ar += f" + {coef:.4f}Â·y_t-{i}"

    # Coeficientes MA (no estacional)
    for i in range(1, q + 1):
        if f"ma.L{i}" in params:
            coef = params[f"ma.L{i}"]
            parte_ma += f" + {coef:.4f}Â·Îµ_t-{i}"

    # Coeficientes SAR (estacional)
    for i in range(1, P + 1):
        if f"ar.S.L{m*i}" in params:
            coef = params[f"ar.S.L{m*i}"]
            parte_sar += f" + {coef:.4f}Â·y_t-{m*i}"

    # Coeficientes SMA (estacional)
    for i in range(1, Q + 1):
        if f"ma.S.L{m*i}" in params:
            coef = params[f"ma.S.L{m*i}"]
            parte_sma += f" + {coef:.4f}Â·Îµ_t-{m*i}"

    # Constante
    constante = ""
    if "intercept" in params:
        constante = f"{params['intercept']:.4f} + "
    elif "const" in params:
        constante = f"{params['const']:.4f} + "

    # Construir ecuaciÃ³n
    if d == 0 and D == 0:
        ecuacion = f"y_t = {constante}"
    else:
        # Para modelos con diferenciaciÃ³n
        ecuacion = "Î”^d Î”_s^D y_t = "
        if constante.strip():
            ecuacion = f"Î”^d Î”_s^D y_t = {constante}"

    # Agregar partes
    if parte_ar:
        ecuacion += parte_ar[3:] if ecuacion.endswith("= ") else parte_ar
    if parte_ma:
        ecuacion += parte_ma
    if parte_sar:
        ecuacion += parte_sar
    if parte_sma:
        ecuacion += parte_sma

    if parte_ar or parte_ma or parte_sar or parte_sma:
        ecuacion += " + Îµ_t"
    else:
        ecuacion += "Îµ_t"

    return ecuacion

# ======================================================
# 4. FUNCIÃ“N PARA MOSTRAR PARÃMETROS COMO EN LA IMAGEN
# ======================================================
def mostrar_parametros_tabla(modelo, orden, orden_seas, aic):
    """
    Muestra los parÃ¡metros en formato de tabla como en la imagen
    """
    params = modelo.params
    p, d, q = orden
    P, D, Q, m = orden_seas

    print("\n" + "=" * 60)
    print("PARÃMETROS DEL MODELO SARIMA")
    print("=" * 60)

    # Crear lista de parÃ¡metros
    parametros_lista = []

    # ParÃ¡metros AR
    for i in range(1, p + 1):
        key = f"ar.L{i}"
        if key in params:
            parametros_lista.append((f"Ï†_{i}", params[key], modelo.bse.get(key, "N/A")))

    # ParÃ¡metros MA
    for i in range(1, q + 1):
        key = f"ma.L{i}"
        if key in params:
            parametros_lista.append((f"Î¸_{i}", params[key], modelo.bse.get(key, "N/A")))

    # ParÃ¡metros SAR
    for i in range(1, P + 1):
        key = f"ar.S.L{m*i}"
        if key in params:
            parametros_lista.append((f"Î¦_{i}", params[key], modelo.bse.get(key, "N/A")))

    # ParÃ¡metros SMA
    for i in range(1, Q + 1):
        key = f"ma.S.L{m*i}"
        if key in params:
            parametros_lista.append((f"Î˜_{i}", params[key], modelo.bse.get(key, "N/A")))

    # Constante
    if "intercept" in params:
        parametros_lista.append(
            ("intercept", params["intercept"], modelo.bse.get("intercept", "N/A"))
        )
    elif "const" in params:
        parametros_lista.append(
            ("const", params["const"], modelo.bse.get("const", "N/A"))
        )

    # Varianza del error
    if "sigma2" in params:
        parametros_lista.append(
            ("ÏƒÂ²", params["sigma2"], modelo.bse.get("sigma2", "N/A"))
        )

    # Mostrar tabla
    print(f"\nOrden: SARIMA{orden}{orden_seas}")
    print(f"AIC: {aic:.2f}")
    print("\n" + "-" * 60)
    print(f"{'ParÃ¡metro':<15} {'Valor':<15} {'Error estÃ¡ndar':<15}")
    print("-" * 60)

    for nombre, valor, error in parametros_lista:
        if isinstance(error, (int, float)):
            print(f"{nombre:<15} {valor:<15.4f} {error:<15.4f}")
        else:
            print(f"{nombre:<15} {valor:<15.4f} {str(error):<15}")

    print("-" * 60)

# ======================================================
# 5. FUNCIÃ“N PARA GRAFICAR PRONÃ“STICO CON FECHAS MEJORADAS
# ======================================================
def graficar_pronostico(modelo, series, pasos=48, limite=None):
    pred = modelo.get_forecast(steps=pasos)
    media = pred.predicted_mean
    conf_80 = pred.conf_int(alpha=0.20)
    conf_95 = pred.conf_int(alpha=0.05)

    # Crear figura con tamaÃ±o adecuado
    fig, ax = plt.subplots(figsize=(15, 6))

    # Datos histÃ³ricos
    ax.plot(series.index, series.values, label="Medido", color="black", linewidth=1.5)

    # PronÃ³stico
    ax.plot(
        media.index,
        media.values,
        label=f"PronÃ³stico {series.name}",
        color="red",
        linewidth=2,
    )

    # Bandas de confianza
    ax.fill_between(
        conf_80.index,
        conf_80.iloc[:, 0],
        conf_80.iloc[:, 1],
        color="green",
        alpha=0.3,
        label="Confianza 80%",
    )
    ax.fill_between(
        conf_95.index,
        conf_95.iloc[:, 0],
        conf_95.iloc[:, 1],
        color="yellow",
        alpha=0.2,
        label="Confianza 95%",
    )

    # LÃ­nea vertical para separar historial de pronÃ³stico
    ultimo_historial = series.index[-1]
    ax.axvline(x=ultimo_historial, color="gray", linestyle="--", alpha=0.7, linewidth=1)

    # LÃ­nea de norma o lÃ­mite permitido
    if limite is not None:
        ax.axhline(
            y=limite,
            color="blue",
            linestyle="--",
            linewidth=2,
            label="Nivel mÃ¡ximo permitido (24H) en Colombia",
        )

    # Configurar formato de fechas
    # Determinar el rango de fechas
    fecha_min = series.index.min()
    fecha_max = media.index.max()

    # Calcular diferencia de dÃ­as para determinar el formato
    dias_totales = (fecha_max - fecha_min).days

    if dias_totales <= 7:  # Si es menos de una semana
        # Formato: DÃ­a Hora (ej: "11 Nov 10:00")
        ax.xaxis.set_major_formatter(mdates.DateFormatter("%d %b %H:%M"))
        ax.xaxis.set_major_locator(mdates.HourLocator(interval=6))
    elif dias_totales <= 30:  # Si es menos de un mes
        # Formato: DÃ­a Mes (ej: "11 Nov")
        ax.xaxis.set_major_formatter(mdates.DateFormatter("%d %b"))
        ax.xaxis.set_major_locator(mdates.DayLocator(interval=2))
    else:  # Si es mÃ¡s de un mes
        # Formato: Mes (ej: "Nov 2025")
        ax.xaxis.set_major_formatter(mdates.DateFormatter("%b %Y"))
        ax.xaxis.set_major_locator(mdates.MonthLocator())

    # Rotar etiquetas para mejor lectura
    plt.setp(ax.xaxis.get_majorticklabels(), rotation=45, ha="right")

    # Agregar leyenda de separaciÃ³n
    ax.text(
        ultimo_historial + timedelta(hours=1),
        ax.get_ylim()[1] * 0.95,
        "PronÃ³stico",
        fontsize=10,
        color="darkred",
        alpha=0.8,
    )

    # TÃ­tulos y etiquetas
    ax.set_title(f"PronÃ³stico SARIMA - {series.name}", fontsize=14, fontweight="bold")
    ax.set_xlabel("Fecha y Hora", fontsize=12)

    # Etiqueta del eje Y dependiendo de la variable
    if series.name == "Temperature":
        ax.set_ylabel("Temperatura (Â°C)", fontsize=12)
    elif series.name == "Humidity":
        ax.set_ylabel("Humedad (%)", fontsize=12)
    elif series.name in ["PM 2.5", "PM 10"]:
        ax.set_ylabel(f"{series.name} (Âµg/mÂ³)", fontsize=12)
    else:
        ax.set_ylabel(series.name, fontsize=12)

    # CuadrÃ­cula
    ax.grid(True, alpha=0.3, linestyle="--")

    # Leyenda
    ax.legend(loc="upper left", fontsize=10)

    # Ajustar mÃ¡rgenes
    plt.tight_layout()

    plt.show()



# ======================================================
# 6. EJECUCIÃ“N COMPLETA POR VARIABLE
# ======================================================
limites = {
    "Temperature": None,
    "Humidity": None,
    "PM 2.5": 37,  # valor OMS o Colombia
    "PM 10": 75,
}

resultados = {}
ecuaciones = {}
parametros_tablas = {}

for var in variables:
    print(f"\n{'='*80}")
    print(f" OPTIMIZANDO: {var}")
    print(f"{'='*80}")

    serie = df_hourly[var]

    modelo, orden, orden_s, aic, parametros, summary = buscar_mejor_modelo(serie)

    print(f"\nMejor modelo para {var}: SARIMA{orden}{orden_s}")
    print(f"AIC = {aic:.2f}")

    # Obtener y mostrar ecuaciÃ³n matemÃ¡tica
    ecuacion = obtener_ecuacion_sarima(modelo, orden, orden_s)
    print(f"\nEcuaciÃ³n matemÃ¡tica:")
    print(f"{ecuacion}")

    # Mostrar parÃ¡metros en formato de tabla
    mostrar_parametros_tabla(modelo, orden, orden_s, aic)

    # Guardar resultados
    resultados[var] = modelo
    ecuaciones[var] = ecuacion
    parametros_tablas[var] = {
        "orden": orden,
        "orden_estacional": orden_s,
        "aic": aic,
        "parametros": parametros,
        "summary": summary,
    }

    # Graficar pronÃ³stico (72 horas adelante)
    graficar_pronostico(modelo, serie, pasos=72, limite=limites[var])

# ======================================================
# 7. RESUMEN FINAL DE TODOS LOS MODELOS
# ======================================================
print(f"\n{'='*80}")
print(" RESUMEN FINAL DE MODELOS SARIMA")
print(f"{'='*80}")

for var in variables:
    print(f"\n{var}:")
    print(f"  Modelo: SARIMA{resultados[var].specification.order}")
    print(f"          {resultados[var].specification.seasonal_order}")
    print(f"  AIC: {resultados[var].aic:.2f}")
    print(f"  EcuaciÃ³n: {ecuaciones[var]}")
    print(f"  NÃºmero de observaciones: {len(df_hourly[var])}")

