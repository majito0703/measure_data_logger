<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5, user-scalable=yes" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>Dashboard Pro - Measure Data Logger</title>

  <!-- Librerías -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/luxon@3.0.0/build/global/luxon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.1.0/dist/chartjs-adapter-luxon.min.js"></script>

  <style>
    :root {
      --ucc-azul: #003366;
      --ucc-verde: #7AC043;
      --ucc-verde-claro: #9FD66D;
      --gris: #F2F2F2;
      --gris-oscuro: #E5E7EB;
      --text: #0b1220;
      --card-bg: #ffffff;
      --shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06);
      --shadow-lg: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05);
      --transition: all 0.3s cubic-bezier(0.4,0,0.2,1);
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to   { opacity: 1; transform: translateY(0); }
    }
    @keyframes slideIn {
      from { transform: translateX(-100%); opacity: 0; }
      to   { transform: translateX(0); opacity: 1; }
    }
    @keyframes spin {
      0%   { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    * { box-sizing: border-box; }
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
      margin: 0;
      background: var(--gris);
      color: var(--text);
      transition: var(--transition);
      line-height: 1.6;
    }

    header {
      background: linear-gradient(135deg, var(--ucc-azul) 0%, #002347 100%);
      color: #fff;
      padding: 20px 24px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      box-shadow: var(--shadow-lg);
      position: sticky;
      top: 0;
      z-index: 1000;
      backdrop-filter: blur(10px);
    }

    .header-title {
      font-weight: 700;
      letter-spacing: 1px;
      font-size: 20px;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .header-logo {
      width: 40px;
      height: 40px;
      background: var(--ucc-verde);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: var(--shadow);
    }

    .header-actions {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    .btn {
      background: linear-gradient(135deg, var(--ucc-verde) 0%, var(--ucc-verde-claro) 100%);
      border: none;
      padding: 10px 18px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
      color: white;
      transition: var(--transition);
      box-shadow: var(--shadow);
      font-size: 14px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .btn:hover { transform: translateY(-2px); box-shadow: var(--shadow-lg); }

    .btn.secondary {
      background: #ffffff;
      color: var(--ucc-azul);
      border: 2px solid var(--gris-oscuro);
    }

    .icon-btn {
      background: rgba(255,255,255,0.1);
      border: 2px solid rgba(255,255,255,0.2);
      color: #fff;
      padding: 8px;
      border-radius: 10px;
      cursor: pointer;
      transition: var(--transition);
      backdrop-filter: blur(10px);
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .icon-btn:hover {
      background: rgba(255,255,255,0.2);
      border-color: rgba(255,255,255,0.3);
    }

    .container { max-width: 1400px; margin: 24px auto; padding: 0 20px; animation: fadeIn 0.5s ease-out; }

    .kpi-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 20px;
      margin-bottom: 24px;
    }

    .kpi-card {
      background: var(--card-bg);
      border-radius: 16px;
      padding: 20px;
      box-shadow: var(--shadow);
      display: flex;
      align-items: center;
      gap: 16px;
      transition: var(--transition);
      position: relative;
      overflow: hidden;
      border: 1px solid rgba(0,0,0,0.05);
    }

    .kpi-card:hover { transform: translateY(-4px); box-shadow: var(--shadow-lg); }

    .kpi-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 4px;
      height: 100%;
      background: linear-gradient(180deg, var(--ucc-verde), var(--ucc-azul));
    }

    .kpi-icon {
      width: 64px;
      height: 64px;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, var(--ucc-azul), #0a2b5a);
      color: #fff;
      box-shadow: var(--shadow);
      flex-shrink: 0;
    }

    .kpi-body { flex: 1; min-width: 0; }
    .kpi-title {
      font-size: 13px;
      color: #64748b;
      margin: 0 0 8px 0;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .kpi-value {
      font-size: 28px;
      font-weight: 700;
      color: var(--ucc-azul);
      margin: 4px 0;
      display: flex;
      align-items: baseline;
      gap: 8px;
    }
    .kpi-meta { font-size: 12px; color: #94a3b8; margin-top: 4px; }

    .notification {
      position: fixed;
      top: 80px;
      right: 20px;
      background: white;
      padding: 16px 20px;
      border-radius: 12px;
      box-shadow: var(--shadow-lg);
      display: flex;
      align-items: center;
      gap: 12px;
      z-index: 1001;
      animation: slideIn 0.3s ease-out;
      max-width: 400px;
      border-left: 4px solid var(--ucc-verde);
    }

    .notification.error { border-left-color: #ef4444; }
    .notification.warning { border-left-color: #f59e0b; }

    .charts-panel { display: grid; grid-template-columns: 1fr; gap: 20px; margin-bottom: 24px; }

    .controls {
      background: white;
      padding: 16px 20px;
      border-radius: 12px;
      box-shadow: var(--shadow);
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
      margin-bottom: 16px;
    }

    .controls-group { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }

    .range-btn {
      padding: 10px 16px;
      border-radius: 10px;
      border: 2px solid var(--gris-oscuro);
      background: #fff;
      cursor: pointer;
      transition: var(--transition);
      font-weight: 500;
      font-size: 14px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .range-btn:hover { border-color: var(--ucc-azul); background: #f9fafb; }
    .range-btn.active {
      background: var(--ucc-azul);
      color: #fff;
      border-color: var(--ucc-azul);
      box-shadow: var(--shadow);
    }

    .variable-selector {
      display: flex;
      gap: 10px;
      margin-bottom: 16px;
      flex-wrap: wrap;
      background: white;
      padding: 12px;
      border-radius: 12px;
      box-shadow: var(--shadow);
    }

    .variable-btn {
      padding: 10px 18px;
      border-radius: 10px;
      border: 2px solid var(--gris-oscuro);
      background: #fff;
      cursor: pointer;
      font-size: 14px;
      transition: var(--transition);
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .variable-btn:hover { border-color: var(--ucc-azul); background: #f9fafb; }

    .variable-btn.active {
      background: linear-gradient(135deg, var(--ucc-azul), #0a2b5a);
      color: #fff;
      border-color: var(--ucc-azul);
      box-shadow: var(--shadow);
    }

    .canvas-card {
      background: var(--card-bg);
      padding: 20px;
      border-radius: 16px;
      box-shadow: var(--shadow);
      border: 1px solid rgba(0,0,0,0.05);
      transition: var(--transition);
      max-width: 100%;
      overflow: hidden;
    }

    .canvas-card:hover { box-shadow: var(--shadow-lg); }

    .canvas-title {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 2px solid var(--gris);
    }

    .canvas-title strong {
      font-size: 18px;
      color: var(--ucc-azul);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .canvas-card canvas {
      max-height: 300px !important;
      height: 300px !important;
      max-width: 100%;
    }

    .hourly-forecast-container {
      background: var(--card-bg);
      border-radius: 16px;
      padding: 20px;
      box-shadow: var(--shadow);
      margin-top: 20px;
      display: none;
      border: 1px solid rgba(0,0,0,0.05);
      max-width: 100%;
      overflow: hidden;
    }

    .hourly-forecast-title {
      font-size: 18px;
      font-weight: 700;
      color: var(--ucc-azul);
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
      padding-bottom: 12px;
      border-bottom: 2px solid var(--gris);
    }

    .hourly-forecast-scroll {
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: thin;
      scrollbar-color: var(--ucc-verde) #f0f0f0;
      padding: 10px 0;
    }

    .hourly-forecast-scroll::-webkit-scrollbar { height: 10px; }
    .hourly-forecast-scroll::-webkit-scrollbar-track { background: var(--gris); border-radius: 10px; }
    .hourly-forecast-scroll::-webkit-scrollbar-thumb {
      background: linear-gradient(90deg, var(--ucc-verde), var(--ucc-verde-claro));
      border-radius: 10px;
    }

    .hourly-forecast {
      display: flex;
      gap: 16px;
      padding-bottom: 10px;
      min-width: min-content;
      justify-content: flex-start;
    }

    .hour-card {
      background: linear-gradient(180deg, #f8f9fa 0%, #ffffff 100%);
      border-radius: 16px;
      padding: 16px 20px;
      min-width: 130px;
      max-width: 150px;
      text-align: center;
      border: 2px solid transparent;
      transition: var(--transition);
      cursor: pointer;
      position: relative;
      box-shadow: var(--shadow);
      flex-shrink: 0;
    }

    .hour-card:hover {
      transform: translateY(-6px);
      border-color: var(--ucc-verde);
      box-shadow: var(--shadow-lg);
    }

    .hour-card.current {
      background: linear-gradient(135deg, var(--ucc-azul) 0%, #002347 100%);
      color: white;
      border-color: var(--ucc-verde);
      box-shadow: var(--shadow-lg);
    }

    .hour-time {
      font-size: 11px;
      font-weight: 700;
      color: #64748b;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .hour-card.current .hour-time { color: rgba(255,255,255,0.9); }

    .hour-day {
      font-size: 14px;
      font-weight: 700;
      margin-bottom: 8px;
      color: var(--ucc-azul);
    }

    .hour-card.current .hour-day { color: white; }

    .hour-icon {
      width: 56px;
      height: 56px;
      margin: 12px auto;
      display: flex;
      align-items: center;
      justify-content: center;
      background: white;
      border-radius: 50%;
      box-shadow: var(--shadow);
    }

    .hour-card.current .hour-icon {
      background: rgba(255,255,255,0.15);
      backdrop-filter: blur(10px);
    }

    .hour-value {
      font-size: 26px;
      font-weight: 700;
      color: var(--ucc-azul);
      margin: 10px 0;
    }

    .hour-card.current .hour-value { color: white; }

    .hour-range {
      font-size: 11px;
      color: #94a3b8;
      margin-top: 6px;
      font-weight: 500;
    }

    .hour-card.current .hour-range { color: rgba(255,255,255,0.7); }

    .hour-label {
      font-size: 11px;
      color: #64748b;
      margin-top: 6px;
      font-weight: 600;
    }

    .hour-card.current .hour-label { color: rgba(255,255,255,0.8); }

    .forecast-badge {
      position: absolute;
      top: 10px;
      right: 10px;
      background: linear-gradient(135deg, var(--ucc-verde), var(--ucc-verde-claro));
      color: white;
      font-size: 10px;
      padding: 4px 8px;
      border-radius: 8px;
      font-weight: 700;
      box-shadow: var(--shadow);
    }

    .forecast-tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 20px;
      border-bottom: 2px solid var(--gris);
      padding-bottom: 12px;
      flex-wrap: wrap;
    }

    .forecast-tab {
      padding: 10px 18px;
      background: #f8f9fa;
      border: none;
      border-radius: 10px 10px 0 0;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: var(--transition);
      border: 2px solid transparent;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .forecast-tab:hover { background: var(--gris-oscuro); }

    .forecast-tab.active {
      background: var(--ucc-azul);
      color: white;
      border-bottom: 3px solid var(--ucc-verde);
      box-shadow: var(--shadow);
    }

    .forecast-tab.loaded {
      background: #d1fae5;
      color: #059669;
      border-left: 3px solid var(--ucc-verde);
    }

    .forecast-tab.error {
      background: #fee2e2;
      color: #dc2626;
      border-left: 3px solid #ef4444;
    }

    .quick-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 16px;
      margin-top: 20px;
    }

    .stat-card {
      background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
      padding: 16px;
      border-radius: 12px;
      border-left: 4px solid var(--ucc-azul);
      transition: var(--transition);
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .stat-card:hover { transform: translateY(-2px); box-shadow: var(--shadow-lg); }

    .stat-title {
      font-size: 12px;
      color: #64748b;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .stat-value {
      font-size: 22px;
      font-weight: 700;
      color: var(--ucc-azul);
    }

    .stat-subtitle {
      font-size: 11px;
      color: #94a3b8;
    }

    .table-card {
      background: var(--card-bg);
      padding: 20px;
      border-radius: 16px;
      box-shadow: var(--shadow);
      margin-bottom: 40px;
      border: 1px solid rgba(0,0,0,0.05);
      max-width: 100%;
      overflow: hidden;
    }

    .table-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      justify-content: space-between;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 2px solid var(--gris);
    }

    .table-search {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    .input {
      padding: 10px 14px;
      border-radius: 10px;
      border: 2px solid var(--gris-oscuro);
      transition: var(--transition);
      font-size: 14px;
    }

    .input:focus {
      outline: none;
      border-color: var(--ucc-azul);
      box-shadow: 0 0 0 3px rgba(0,51,102,0.1);
    }

    .pagination-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 20px;
      padding-top: 16px;
      border-top: 2px solid var(--gris);
      flex-wrap: wrap;
      gap: 12px;
    }

    .pagination-info {
      font-size: 14px;
      color: #64748b;
      font-weight: 500;
    }

    .pagination-controls {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    .pagination-btn {
      padding: 8px 16px;
      border-radius: 8px;
      border: 2px solid var(--gris-oscuro);
      background: #fff;
      cursor: pointer;
      transition: var(--transition);
      font-weight: 500;
      font-size: 14px;
      min-width: 40px;
      text-align: center;
    }

    .pagination-btn:hover:not(:disabled) { border-color: var(--ucc-azul); background: #f9fafb; }

    .pagination-btn.active {
      background: var(--ucc-azul);
      color: #fff;
      border-color: var(--ucc-azul);
    }

    .pagination-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .page-size-selector {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .page-size-selector select {
      padding: 8px 12px;
      border-radius: 8px;
      border: 2px solid var(--gris-oscuro);
      background: #fff;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      min-width: 100%;
    }

    th, td {
      padding: 14px;
      border-bottom: 1px solid var(--gris);
      text-align: center;
      font-size: 13px;
    }

    th {
      background: linear-gradient(135deg, var(--ucc-azul), #0a2b5a);
      color: #fff;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-size: 12px;
    }

    tbody tr { transition: var(--transition); }
    tbody tr:hover { background: #f9fafb; }

    .loading-spinner {
      display: inline-block;
      width: 18px;
      height: 18px;
      border: 3px solid rgba(0,0,0,0.1);
      border-top: 3px solid var(--ucc-verde);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin-right: 8px;
    }

    .chart-legend {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      justify-content: center;
      margin-top: 16px;
      padding: 16px;
      background: var(--gris);
      border-radius: 12px;
      font-size: 13px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 500;
    }

    .legend-color {
      width: 18px;
      height: 18px;
      border-radius: 4px;
      box-shadow: var(--shadow);
    }

    .badge {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .badge.success { background: #d1fae5; color: #059669; }
    .badge.error { background: #fee2e2; color: #dc2626; }
    .badge.info { background: #dbeafe; color: #2563eb; }

    @media (max-width:900px) {
      .kpi-row { grid-template-columns: repeat(2, 1fr); }
      header { padding: 16px; }
      #pdfBtn { display: none; }
      .quick-stats { grid-template-columns: 1fr; }
      .header-title { font-size: 16px; }
      .container { padding: 0 16px; }
      .hour-card { min-width: 120px; max-width: 140px; }
    }

    @media (max-width:560px) {
      header { flex-direction: column; align-items: flex-start; gap: 12px; padding: 12px 16px; }
      .header-title { font-size: 14px; width: 100%; }
      .header-logo { width: 32px; height: 32px; }
      .header-actions { width: 100%; justify-content: flex-start; }
      .kpi-row { grid-template-columns: 1fr; gap: 12px; }
      .kpi-card { padding: 16px; }
      .kpi-icon { width: 52px; height: 52px; }
      .kpi-value { font-size: 24px; }
      .controls { flex-direction: column; align-items: stretch; padding: 12px; gap: 8px; }
      .controls-group { flex-direction: column; width: 100%; gap: 8px; }
      .range-btn { width: 100%; padding: 12px; font-size: 13px; }
      .variable-selector { flex-direction: column; padding: 10px; }
      .variable-btn { width: 100%; justify-content: center; padding: 12px; }
      .charts-panel { gap: 12px; }
      .canvas-card { padding: 12px; }
      .canvas-card canvas { max-height: 250px !important; height: 250px !important; }
      .forecast-tabs { flex-direction: column; gap: 6px; }
      .forecast-tab { width: 100%; text-align: center; padding: 10px; border-radius: 8px; }
      .quick-stats { grid-template-columns: 1fr; gap: 10px; }
      .hourly-forecast-container { padding: 12px; }
      .hour-card { min-width: 110px; max-width: 120px; padding: 12px 14px; }
      .hour-icon { width: 48px; height: 48px; }
      .hour-value { font-size: 22px; }
      .table-card { padding: 12px; margin-bottom: 20px; }
      .table-controls { flex-direction: column; align-items: stretch; gap: 10px; }
      .table-search { flex-direction: column; width: 100%; }
      .table-search input, .table-search button { width: 100%; }
      table { font-size: 11px; }
      th, td { padding: 8px 4px; font-size: 11px; }
      .pagination-container { flex-direction: column; align-items: stretch; }
      .pagination-controls { justify-content: center; }
      .pagination-info { text-align: center; }
      .btn { padding: 10px 14px; font-size: 13px; }
      .container { padding: 0 10px; margin: 16px auto; }
      .notification { top: 10px; right: 10px; left: 10px; max-width: none; font-size: 13px; }
      .chart-legend { flex-direction: column; align-items: flex-start; gap: 10px; font-size: 12px; }
    }

    body.dark {
      --card-bg: #1a1f2e;
      --gris: #0b1220;
      --gris-oscuro: #1e293b;
      --text: #e2e8f0;
      background: #0b1220;
      color: #e2e8f0;
    }

    body.dark .kpi-card,
    body.dark .canvas-card,
    body.dark .table-card,
    body.dark .controls,
    body.dark .variable-selector,
    body.dark .hourly-forecast-container {
      background: #1a1f2e;
      box-shadow: 0 4px 6px -1px rgba(0,0,0,0.3);
      border-color: rgba(255,255,255,0.1);
    }

    body.dark th {
      background: linear-gradient(135deg, #1e3a5f, #0f2744);
    }

    body.dark .kpi-value { color: var(--ucc-verde-claro); }

    body.dark .stat-card,
    body.dark .hour-card {
      background: linear-gradient(135deg, #1e293b 0%, #1a1f2e 100%);
      border-left-color: var(--ucc-verde);
    }

    body.dark .forecast-tab:not(.active) {
      background: #1e293b;
      color: #e2e8f0;
    }

    body.dark .variable-btn,
    body.dark .input,
    body.dark .range-btn,
    body.dark .pagination-btn {
      background: #1e293b;
      color: #e2e8f0;
      border-color: #334155;
    }

    body.dark tbody tr:hover { background: #1e293b; }
    body.dark .chart-legend { background: #1e293b; }
    body.dark .notification { background: #1a1f2e; color: #e2e8f0; }

    html { scroll-behavior: smooth; }

    .icon-svg {
      width: 20px;
      height: 20px;
      stroke: currentColor;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round;
      fill: none;
      flex-shrink: 0;
    }

    .kpi-icon .icon-svg {
      width: 40px;
      height: 40px;
    }

    .hour-icon .icon-svg {
      width: 36px;
      height: 36px;
    }

    .pdf-modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.8);
  z-index: 9999;
  justify-content: center;
  align-items: center;
}

.pdf-modal.active {
  display: flex;
}

.pdf-modal-content {
  background: white;
  padding: 40px;
  border-radius: 16px;
  box-shadow: var(--shadow-lg);
  text-align: center;
  max-width: 500px;
  width: 90%;
}

.pdf-progress-bar {
  width: 100%;
  height: 8px;
  background: var(--gris);
  border-radius: 10px;
  overflow: hidden;
  margin: 20px 0;
}

.pdf-progress-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--ucc-verde), var(--ucc-verde-claro));
  width: 0%;
  transition: width 0.3s ease;
  border-radius: 10px;
}

body.dark .pdf-modal-content { 
  background: #1a1f2e; 
  color: #e2e8f0; 
}
  </style>
</head>
<body>
  <!-- ═══ MODAL DE PROGRESO PDF ═══ -->
  <div class="pdf-modal" id="pdfModal">
    <div class="pdf-modal-content">
      <h2 style="color: var(--ucc-azul); margin-bottom: 10px;">Generando Reporte PDF</h2>
      <p id="pdfStatus">Inicializando...</p>
      <div class="pdf-progress-bar">
        <div class="pdf-progress-fill" id="pdfProgress"></div>
      </div>
      <p style="font-size: 12px; color: #64748b;">Por favor espere, esto puede tomar unos segundos</p>
    </div>
  </div>
  <!-- Definición de iconos SVG reutilizables -->
  <svg style="display: none;">
    <!-- Dashboard / Analítica -->
    <symbol id="i-dashboard" viewBox="0 0 24 24">
      <path d="M3 13h4v8H3zM9 9h4v12H9zM15 5h4v16h-4z"/>
    </symbol>

    <!-- Termómetro / Temperatura -->
    <symbol id="i-thermometer" viewBox="0 0 24 24">
      <path d="M14 14.76V3.5a2.5 2.5 0 0 0-5 0v11.26a4.5 4.5 0 1 0 5 0z"/>
    </symbol>

    <!-- Gota / Humedad -->
    <symbol id="i-droplet" viewBox="0 0 24 24">
      <path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"/>
    </symbol>

    <!-- Sol / Radiación -->
    <symbol id="i-sun" viewBox="0 0 24 24">
      <circle cx="12" cy="12" r="5"/>
      <line x1="12" y1="1" x2="12" y2="3"/>
      <line x1="12" y1="21" x2="12" y2="23"/>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
      <line x1="1" y1="12" x2="3" y2="12"/>
      <line x1="21" y1="12" x2="23" y2="12"/>
    </symbol>

    <!-- Nube / PM10 - PM2.5 -->
    <symbol id="i-cloud-pollution" viewBox="0 0 24 24">
      <path d="M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9z"/>
      <circle cx="7" cy="17" r="2"/>
      <circle cx="12" cy="13" r="2"/>
      <circle cx="17" cy="9" r="2"/>
    </symbol>

    <!-- Descargar / CSV -->
    <symbol id="i-download" viewBox="0 0 24 24">
      <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
      <polyline points="7 10 12 15 17 10"/>
      <line x1="12" y1="15" x2="12" y2="3"/>
    </symbol>

    <!-- PDF / Documento -->
    <symbol id="i-file-text" viewBox="0 0 24 24">
      <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
      <polyline points="14 2 14 8 20 8"/>
      <line x1="9" y1="13" x2="15" y2="13"/>
      <line x1="9" y1="17" x2="15" y2="17"/>
    </symbol>

    <!-- Luna (modo oscuro) -->
    <symbol id="i-moon" viewBox="0 0 24 24">
      <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
    </symbol>

    <!-- Sol (modo claro) -->
    <symbol id="i-sun-fill" viewBox="0 0 24 24">
      <circle cx="12" cy="12" r="5" fill="currentColor"/>
      <line x1="12" y1="1" x2="12" y2="3"/>
      <line x1="12" y1="21" x2="12" y2="23"/>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
    </symbol>

    <!-- Lupa / Buscar -->
    <symbol id="i-search" viewBox="0 0 24 24">
      <circle cx="11" cy="11" r="8"/>
      <line x1="21" y1="21" x2="16.65" y2="16.65"/>
    </symbol>

    <!-- Limpiar / Basurero -->
    <symbol id="i-trash" viewBox="0 0 24 24">
      <path d="M3 6h18"/>
      <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
      <line x1="10" y1="11" x2="10" y2="17"/>
      <line x1="14" y1="11" x2="14" y2="17"/>
    </symbol>

    <!-- Calendario / Rango -->
    <symbol id="i-calendar" viewBox="0 0 24 24">
      <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
      <line x1="16" y1="2" x2="16" y2="6"/>
      <line x1="8" y1="2" x2="8" y2="6"/>
      <line x1="3" y1="10" x2="21" y2="10"/>
    </symbol>

    <!-- Gráfico / Pronóstico -->
    <symbol id="i-chart" viewBox="0 0 24 24">
      <path d="M3 3v18h18"/>
      <path d="M7 15l4-4 4 4 4-4"/>
    </symbol>
  </svg>

  <header>
    <div class="header-title">
      <div class="header-logo">
        <svg class="icon-svg" style="width:32px; height:32px;"><use href="#i-dashboard"/></svg>
      </div>
      MEASURE DATA LOGGER – DASHBOARD
    </div>
    <div class="header-actions">
      <button id="pdfBtn" class="btn">
        <svg class="icon-svg"><use href="#i-file-text"/></svg>
        Exportar PDF
      </button>
      <button id="csvBtn" class="btn secondary">
        <svg class="icon-svg"><use href="#i-download"/></svg>
        Descargar CSV
      </button>
      <button id="modoOscuroBtn" class="icon-btn" title="Modo oscuro">
        <svg class="icon-svg" id="theme-icon"><use href="#i-moon"/></svg>
      </button>
    </div>
  </header>

  <div class="container" id="contentPDF">

    <!-- KPI Cards -->
    <div class="kpi-row">
      <div class="kpi-card">
        <div class="kpi-icon">
          <svg class="icon-svg"><use href="#i-thermometer"/></svg>
        </div>
        <div class="kpi-body">
          <div class="kpi-title">Temperatura</div>
          <div class="kpi-value">
            <span id="card_temp">--</span>
            <span style="font-size: 18px; color: #64748b;">°C</span>
          </div>
          <div class="kpi-meta" id="meta_temp">Cargando...</div>
        </div>
      </div>

      <div class="kpi-card">
        <div class="kpi-icon">
          <svg class="icon-svg"><use href="#i-droplet"/></svg>
        </div>
        <div class="kpi-body">
          <div class="kpi-title">Humedad</div>
          <div class="kpi-value">
            <span id="card_hum">--</span>
            <span style="font-size: 18px; color: #64748b;">%</span>
          </div>
          <div class="kpi-meta" id="meta_hum">Cargando...</div>
        </div>
      </div>

      <div class="kpi-card">
        <div class="kpi-icon">
          <svg class="icon-svg"><use href="#i-sun"/></svg>
        </div>
        <div class="kpi-body">
          <div class="kpi-title">Radiación</div>
          <div class="kpi-value">
            <span id="card_rad">--</span>
            <span style="font-size: 16px; color: #64748b;">W/m²</span>
          </div>
          <div class="kpi-meta" id="meta_rad">Cargando...</div>
        </div>
      </div>

      <div class="kpi-card">
        <div class="kpi-icon">
          <svg class="icon-svg"><use href="#i-cloud-pollution"/></svg>
        </div>
        <div class="kpi-body">
          <div class="kpi-title">PM10</div>
          <div class="kpi-value">
            <span id="card_pm10">--</span>
            <span style="font-size: 16px; color: #64748b;">µg/m³</span>
          </div>
          <div class="kpi-meta" id="meta_pm10">Cargando...</div>
        </div>
      </div>

      <div class="kpi-card">
        <div class="kpi-icon">
          <svg class="icon-svg"><use href="#i-cloud-pollution"/></svg>
        </div>
        <div class="kpi-body">
          <div class="kpi-title">PM2.5</div>
          <div class="kpi-value">
            <span id="card_pm25">--</span>
            <span style="font-size: 16px; color: #64748b;">µg/m³</span>
          </div>
          <div class="kpi-meta" id="meta_pm25">Cargando...</div>
        </div>
      </div>
    </div>

    <!-- Controls & Charts -->
    <div class="charts-panel">
      <div class="controls">
        <div class="controls-group">
          <button class="range-btn active" data-range="24h">
            <svg class="icon-svg"><use href="#i-calendar"/></svg>
            Últimas 24h
          </button>
          <button class="range-btn" data-range="7d">
            <svg class="icon-svg"><use href="#i-calendar"/></svg>
            Última semana
          </button>
          <button class="range-btn" data-range="all">
            <svg class="icon-svg"><use href="#i-dashboard"/></svg>
            Todo
          </button>
          <button class="range-btn" data-range="forecast" id="forecastBtn">
            <svg class="icon-svg"><use href="#i-chart"/></svg>
            Pronósticos
          </button>
        </div>
        <div class="controls-group" style="margin-left: auto;">
          <label style="font-size: 13px; color: #64748b; font-weight: 500;">Desde</label>
          <input type="datetime-local" id="fromInput" class="input" />
          <label style="font-size: 13px; color: #64748b; font-weight: 500;">Hasta</label>
          <input type="datetime-local" id="toInput" class="input" />
          <button id="applyRange" class="range-btn">Aplicar</button>
        </div>
      </div>

      <div class="variable-selector" id="variableSelector">
        <button class="variable-btn active" data-variable="temp">
          <svg class="icon-svg"><use href="#i-thermometer"/></svg>
          Temperatura
        </button>
        <button class="variable-btn" data-variable="hum">
          <svg class="icon-svg"><use href="#i-droplet"/></svg>
          Humedad
        </button>
        <button class="variable-btn" data-variable="rad">
          <svg class="icon-svg"><use href="#i-sun"/></svg>
          Radiación Solar
        </button>
        <button class="variable-btn" data-variable="pm10">
          <svg class="icon-svg"><use href="#i-cloud-pollution"/></svg>
          PM10
        </button>
        <button class="variable-btn" data-variable="pm25">
          <svg class="icon-svg"><use href="#i-cloud-pollution"/></svg>
          PM2.5
        </button>
      </div>

      <div class="canvas-card" id="mainChartCard">
        <div class="canvas-title">
          <strong id="mainChartTitle">
            <svg class="icon-svg"><use href="#i-thermometer"/></svg>
            Temperatura (°C)
          </strong>
          <small id="main-note" style="color: #64748b;"></small>
        </div>
        <canvas id="mainChart"></canvas>
      </div>

      <div class="hourly-forecast-container" id="hourlyForecastContainer">
        <div class="hourly-forecast-title">
          <svg class="icon-svg"><use href="#i-calendar"/></svg>
          Pronóstico Diario (24 horas)
        </div>
        <div class="hourly-forecast-scroll">
          <div class="hourly-forecast" id="hourlyForecast"></div>
        </div>
      </div>

      <div class="canvas-card" id="forecastChartContainer" style="display: none;">
        <div class="canvas-title">
          <strong id="forecastTitle">
            <svg class="icon-svg"><use href="#i-chart"/></svg>
            Pronósticos SARIMA
          </strong>
          <div>
            <span class="loading-spinner" id="forecastLoading" style="display: none;"></span>
            <small id="forecastInfo" style="color: #64748b;">Selecciona una variable</small>
          </div>
        </div>
        <div class="forecast-tabs" id="forecastTabs">
          <button class="forecast-tab active" data-variable="temperature">
            <svg class="icon-svg"><use href="#i-thermometer"/></svg>
            Temperatura
          </button>
          <button class="forecast-tab" data-variable="humidity">
            <svg class="icon-svg"><use href="#i-droplet"/></svg>
            Humedad
          </button>
          <button class="forecast-tab" data-variable="radiation">
            <svg class="icon-svg"><use href="#i-sun"/></svg>
            Radiación Solar
          </button>
          <button class="forecast-tab" data-variable="pm2.5">
            <svg class="icon-svg"><use href="#i-cloud-pollution"/></svg>
            PM2.5
          </button>
          <button class="forecast-tab" data-variable="pm10">
            <svg class="icon-svg"><use href="#i-cloud-pollution"/></svg>
            PM10
          </button>
        </div>
        <div class="quick-stats" id="quickStats" style="display: none;"></div>
        <canvas id="forecastChart"></canvas>
        <div class="chart-legend">
          <div class="legend-item">
            <div class="legend-color" style="background: black;"></div>
            <span>Datos Históricos</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: red;"></div>
            <span>Pronóstico</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: rgba(0, 255, 0, 0.3); border: 1px solid #00c853;"></div>
            <span>Confianza 80%</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: rgba(255, 255, 0, 0.3); border: 1px solid #ffd600;"></div>
            <span>Confianza 95%</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: transparent; border: 1px dashed blue;"></div>
            <span>Límite Permitido (24H) en Colombia</span>
          </div>
        </div>
      </div>
    </div>

    <!-- Tabla con Paginación -->
    <div class="table-card">
      <div class="table-controls">
        <div class="table-search">
          <div style="position: relative; flex: 1; min-width: 200px;">
            <svg class="icon-svg" style="position: absolute; left: 12px; top: 50%; transform: translateY(-50%); color: #64748b;"><use href="#i-search"/></svg>
            <input id="searchInput" class="input" placeholder="Buscar en la tabla..." style="padding-left: 40px; width: 100%;" />
          </div>
          <input id="filterFrom" type="date" class="input" />
          <input id="filterTo" type="date" class="input" />
          <button id="clearFilters" class="range-btn">
            <svg class="icon-svg"><use href="#i-trash"/></svg>
            Limpiar
          </button>
        </div>
        <div class="table-search">
          <button id="exportCSV" class="range-btn">
            <svg class="icon-svg"><use href="#i-download"/></svg>
            Exportar CSV
          </button>
        </div>
      </div>

      <div style="overflow-x: auto;">
        <table id="dataTable">
          <thead>
            <tr>
              <th>Fecha</th>
              <th>Temp (°C)</th>
              <th>Humedad (%)</th>
              <th>Radiación (W/m²)</th>
              <th>PM10 (µg/m³)</th>
              <th>PM2.5 (µg/m³)</th>
            </tr>
          </thead>
          <tbody id="dataTableBody">
            <tr>
              <td colspan="6" style="padding: 40px; text-align: center; color: #94a3b8;">
                <div class="loading-spinner" style="margin: 0 auto 10px;"></div>
                Cargando datos...
              </td>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="pagination-container" id="paginationContainer" style="display: none;">
        <div class="pagination-info" id="paginationInfo">Mostrando 0-0 de 0 registros</div>
        <div class="pagination-controls">
          <button class="pagination-btn" id="firstPage" title="Primera página">⏮</button>
          <button class="pagination-btn" id="prevPage" title="Página anterior">◀</button>
          <div id="pageNumbers" style="display: flex; gap: 4px;"></div>
          <button class="pagination-btn" id="nextPage" title="Página siguiente">▶</button>
          <button class="pagination-btn" id="lastPage" title="Última página">⏭</button>
        </div>
        <div class="page-size-selector">
          <label style="font-size: 14px; color: #64748b;">Registros por página:</label>
          <select id="pageSize">
            <option value="10" selected>10</option>
            <option value="25">25</option>
            <option value="50">50</option>
            <option value="100">100</option>
          </select>
        </div>
      </div>
    </div>
  </div>

  <script>
    const API_URL = "datos/datos_sensores.json";
    const FORECAST_BASE_URL = "https://raw.githubusercontent.com/majito0703/measure_data_logger/main/pronosticos/";
    let rawData = [];
    let filtered = [];
    function calculateStats(data) {
  if (!data || data.length === 0) return null;
  
  const values = data.filter(v => v !== null && !isNaN(v));
  if (values.length === 0) return null;
  
  const sorted = [...values].sort((a, b) => a - b);
  const sum = values.reduce((a, b) => a + b, 0);
  const mean = sum / values.length;
  
  const squaredDiffs = values.map(v => Math.pow(v - mean, 2));
  const variance = squaredDiffs.reduce((a, b) => a + b, 0) / values.length;
  const stdDev = Math.sqrt(variance);
  
  const median = sorted.length % 2 === 0
    ? (sorted[sorted.length / 2 - 1] + sorted[sorted.length / 2]) / 2
    : sorted[Math.floor(sorted.length / 2)];
  
  const q1Index = Math.floor(sorted.length * 0.25);
  const q3Index = Math.floor(sorted.length * 0.75);
  
  return {
    count: values.length,
    min: Math.min(...values),
    max: Math.max(...values),
    mean: mean,
    median: median,
    stdDev: stdDev,
    q1: sorted[q1Index],
    q3: sorted[q3Index]
  };
}
    // ============================================
// MÓDULO DE GENERACIÓN PDF PROFESIONAL
// ============================================

async function generateProfessionalPDF() {
  const modal = document.getElementById('pdfModal');
  const progress = document.getElementById('pdfProgress');
  const status = document.getElementById('pdfStatus');
  
  modal.classList.add('active');
  
  try {
    // Paso 1: Inicializar PDF
    status.textContent = 'Inicializando documento PDF...';
    progress.style.width = '10%';
    
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF('p', 'mm', 'a4');
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    let yPos = 20;
    
    // Colores UCC
    const uccAzul = [0, 51, 102];
    const uccVerde = [122, 192, 67];
    
    // ===== PORTADA =====
    status.textContent = 'Creando portada...';
    progress.style.width = '20%';
    
    // Fondo de portada
    doc.setFillColor(...uccAzul);
    doc.rect(0, 0, pageWidth, 80, 'F');
    
    // Logo simulado (círculo verde)
    doc.setFillColor(...uccVerde);
    doc.circle(pageWidth / 2, 40, 15, 'F');
    
    // Título principal
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(28);
    doc.setFont('helvetica', 'bold');
    doc.text('REPORTE DE SENSORES', pageWidth / 2, 90, { align: 'center' });
    
    doc.setFontSize(16);
    doc.setFont('helvetica', 'normal');
    doc.text('Measure Data Logger - Dashboard Profesional', pageWidth / 2, 100, { align: 'center' });
    
    // Información de fecha
    doc.setTextColor(0, 0, 0);
    doc.setFontSize(12);
    const now = new Date();
    const fechaReporte = now.toLocaleString('es-ES', { 
      day: '2-digit', 
      month: 'long', 
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
    doc.text(`Fecha de generación: ${fechaReporte}`, pageWidth / 2, 120, { align: 'center' });
    
    // Rango de datos
    if (rawData.length > 0) {
      const firstDate = parseDate(rawData[0].fecha);
      const lastDate = parseDate(rawData[rawData.length - 1].fecha);
      const rangoTexto = `Período analizado: ${firstDate.toLocaleDateString('es-ES')} - ${lastDate.toLocaleDateString('es-ES')}`;
      doc.text(rangoTexto, pageWidth / 2, 130, { align: 'center' });
      doc.text(`Total de registros: ${rawData.length}`, pageWidth / 2, 140, { align: 'center' });
    }
    
    // Pie de portada
    doc.setFontSize(10);
    doc.setTextColor(100, 100, 100);
    doc.text('Universidad Cooperativa de Colombia', pageWidth / 2, pageHeight - 20, { align: 'center' });
    doc.text('Sistema de Monitoreo Ambiental', pageWidth / 2, pageHeight - 15, { align: 'center' });
    
    await addExecutiveSummary(doc, uccAzul, uccVerde, pageWidth, pageHeight, status, progress);
    await addVariableCharts(doc, uccAzul, uccVerde, pageWidth, pageHeight, status, progress);
    await addForecastSection(doc, uccAzul, uccVerde, pageWidth, pageHeight, status, progress);
    await addDataTable(doc, uccAzul, pageWidth, pageHeight, status, progress);
    
    // Agregar números de página
    addPageNumbers(doc, pageWidth, pageHeight);
    
    // Finalizar
    status.textContent = 'Finalizando documento...';
    progress.style.width = '100%';
    
    await new Promise(resolve => setTimeout(resolve, 500));
    
    // Guardar PDF
    const fileName = `Reporte_Sensores_${now.getFullYear()}-${(now.getMonth()+1).toString().padStart(2,'0')}-${now.getDate().toString().padStart(2,'0')}.pdf`;
    doc.save(fileName);
    
    showNotification('PDF generado exitosamente', 'success');
    
  } catch (error) {
    console.error('Error generando PDF:', error);
    showNotification('Error al generar PDF: ' + error.message, 'error');
  } finally {
    setTimeout(() => {
      modal.classList.remove('active');
      progress.style.width = '0%';
    }, 1000);
  }
}

async function addExecutiveSummary(doc, uccAzul, uccVerde, pageWidth, pageHeight, status, progress) {
  doc.addPage();
  let yPos = 20;
  
  status.textContent = 'Generando resumen ejecutivo...';
  progress.style.width = '30%';
  
  // Título de sección
  doc.setFillColor(...uccAzul);
  doc.rect(0, yPos - 5, pageWidth, 12, 'F');
  doc.setTextColor(255, 255, 255);
  doc.setFontSize(16);
  doc.setFont('helvetica', 'bold');
  doc.text('1. RESUMEN EJECUTIVO', 15, yPos + 4);
  yPos += 20;
  
  // KPIs actuales
  doc.setTextColor(0, 0, 0);
  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  doc.text('Valores Actuales', 15, yPos);
  yPos += 10;
  
  if (rawData.length > 0) {
    const lastData = rawData[rawData.length - 1];
    const lastDate = parseDate(lastData.fecha);
    
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    doc.text(`Última actualización: ${lastDate.toLocaleString('es-ES')}`, 15, yPos);
    yPos += 10;
    
    const kpiData = [
      ['Variable', 'Valor Actual', 'Unidad'],
      ['Temperatura', lastData.temperatura?.toFixed(2) || 'N/A', '°C'],
      ['Humedad', lastData.humedad?.toFixed(2) || 'N/A', '%'],
      ['Radiación Solar', lastData.radiacion?.toFixed(2) || 'N/A', 'W/m²'],
      ['PM10', lastData.pm10?.toFixed(2) || 'N/A', 'µg/m³'],
      ['PM2.5', lastData.pm25?.toFixed(2) || 'N/A', 'µg/m³']
    ];
    
    doc.autoTable({
      head: [kpiData[0]],
      body: kpiData.slice(1),
      startY: yPos,
      theme: 'grid',
      headStyles: { fillColor: uccAzul, fontSize: 10, fontStyle: 'bold' },
      bodyStyles: { fontSize: 9 },
      alternateRowStyles: { fillColor: [245, 245, 245] },
      margin: { left: 15, right: 15 }
    });
    
    yPos = doc.lastAutoTable.finalY + 15;
  }
  
  // Estadísticas generales
  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  doc.text('Estadísticas del Período', 15, yPos);
  yPos += 10;
  
  const variables = [
    { name: 'Temperatura', key: 'temperatura', unit: '°C' },
    { name: 'Humedad', key: 'humedad', unit: '%' },
    { name: 'Radiación', key: 'radiacion', unit: 'W/m²' },
    { name: 'PM10', key: 'pm10', unit: 'µg/m³' },
    { name: 'PM2.5', key: 'pm25', unit: 'µg/m³' }
  ];
  
  const statsData = [['Variable', 'Mínimo', 'Máximo', 'Media', 'Desv. Est.']];
  
  variables.forEach(v => {
    const values = rawData.map(d => d[v.key]).filter(val => val !== null && !isNaN(val));
    const stats = calculateStats(values);
    
    if (stats) {
      statsData.push([
        `${v.name} (${v.unit})`,
        stats.min.toFixed(2),
        stats.max.toFixed(2),
        stats.mean.toFixed(2),
        stats.stdDev.toFixed(2)
      ]);
    }
  });
  
  doc.autoTable({
    head: [statsData[0]],
    body: statsData.slice(1),
    startY: yPos,
    theme: 'grid',
    headStyles: { fillColor: uccVerde, fontSize: 9, fontStyle: 'bold' },
    bodyStyles: { fontSize: 8 },
    alternateRowStyles: { fillColor: [245, 245, 245] },
    margin: { left: 15, right: 15 }
  });
}

async function addVariableCharts(doc, uccAzul, uccVerde, pageWidth, pageHeight, status, progress) {
  const variables = [
    { name: 'Temperatura', key: 'temperatura', unit: '°C', color: '#003366' },
    { name: 'Humedad', key: 'humedad', unit: '%', color: '#7AC043' },
    { name: 'Radiación', key: 'radiacion', unit: 'W/m²', color: '#f59e0b' },
    { name: 'PM10', key: 'pm10', unit: 'µg/m³', color: '#ef4444' },
    { name: 'PM2.5', key: 'pm25', unit: 'µg/m³', color: '#8b5cf6' }
  ];
  
  for (let i = 0; i < variables.length; i++) {
    doc.addPage();
    let yPos = 20;
    
    const variable = variables[i];
    status.textContent = `Procesando gráfico de ${variable.name}...`;
    progress.style.width = `${40 + (i * 10)}%`;
    
    // Título de sección
    doc.setFillColor(...uccAzul);
    doc.rect(0, yPos - 5, pageWidth, 12, 'F');
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(16);
    doc.setFont('helvetica', 'bold');
    doc.text(`${i + 2}. ANÁLISIS: ${variable.name.toUpperCase()}`, 15, yPos + 4);
    yPos += 20;
    
    // Crear gráfico temporal
    const chartImage = await createChartImage(variable, filtered);
    if (chartImage) {
      doc.addImage(chartImage, 'PNG', 15, yPos, pageWidth - 30, 100);
      yPos += 110;
    }
    
    // Estadísticas detalladas
    doc.setFontSize(12);
    doc.setFont('helvetica', 'bold');
    doc.text(`Estadísticas Detalladas - ${variable.name}`, 15, yPos);
    yPos += 8;
    
    const values = rawData.map(d => d[variable.key]).filter(val => val !== null && !isNaN(val));
    const stats = calculateStats(values);
    
    if (stats) {
      const detailData = [
        ['Métrica', 'Valor'],
        ['Cantidad de registros', stats.count.toString()],
        ['Mínimo', `${stats.min.toFixed(2)} ${variable.unit}`],
        ['Máximo', `${stats.max.toFixed(2)} ${variable.unit}`],
        ['Media', `${stats.mean.toFixed(2)} ${variable.unit}`],
        ['Mediana', `${stats.median.toFixed(2)} ${variable.unit}`],
        ['Desviación estándar', `${stats.stdDev.toFixed(2)} ${variable.unit}`],
        ['Percentil 25 (Q1)', `${stats.q1.toFixed(2)} ${variable.unit}`],
        ['Percentil 75 (Q3)', `${stats.q3.toFixed(2)} ${variable.unit}`],
        ['Rango (Max-Min)', `${(stats.max - stats.min).toFixed(2)} ${variable.unit}`]
      ];
      
      doc.autoTable({
        head: [detailData[0]],
        body: detailData.slice(1),
        startY: yPos,
        theme: 'striped',
        headStyles: { fillColor: uccVerde, fontSize: 10, fontStyle: 'bold' },
        bodyStyles: { fontSize: 9 },
        columnStyles: {
          0: { fontStyle: 'bold', cellWidth: 80 },
          1: { cellWidth: 'auto' }
        },
        margin: { left: 15, right: 15 }
      });
      
      yPos = doc.lastAutoTable.finalY + 10;
      
      // Análisis de tendencia
      if (yPos < pageHeight - 40) {
        doc.setFontSize(11);
        doc.setFont('helvetica', 'bold');
        doc.text('Análisis de Tendencia:', 15, yPos);
        yPos += 6;
        
        doc.setFontSize(9);
        doc.setFont('helvetica', 'normal');
        
        const range = stats.max - stats.min;
        const cv = (stats.stdDev / stats.mean) * 100; // Coeficiente de variación
        
        let tendencia = '';
        if (cv < 10) {
          tendencia = 'La variable muestra baja variabilidad, indicando condiciones estables.';
        } else if (cv < 30) {
          tendencia = 'La variable presenta variabilidad moderada.';
        } else {
          tendencia = 'La variable muestra alta variabilidad, con fluctuaciones significativas.';
        }
        
        doc.text(`• ${tendencia}`, 20, yPos);
        yPos += 5;
        doc.text(`• Coeficiente de variación: ${cv.toFixed(2)}%`, 20, yPos);
        yPos += 5;
        doc.text(`• Amplitud del rango: ${range.toFixed(2)} ${variable.unit}`, 20, yPos);
      }
    }
  }
}

async function createChartImage(variable, dataFiltered) {
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = 800;
  tempCanvas.height = 400;
  const tempCtx = tempCanvas.getContext('2d');
  
  const chartData = dataFiltered.map(r => r[variable.key]);
  const chartLabels = dataFiltered.map(r => parseDate(r.fecha));
  
  const tempChart = new Chart(tempCtx, {
    type: 'line',
    data: {
      labels: chartLabels,
      datasets: [{
        label: `${variable.name} (${variable.unit})`,
        data: chartData,
        borderColor: variable.color,
        backgroundColor: variable.color + '20',
        fill: true,
        tension: 0.4,
        pointRadius: 3,
        pointBackgroundColor: variable.color,
        pointBorderColor: '#fff',
        pointBorderWidth: 2
      }]
    },
    options: {
      responsive: false,
      animation: false,
      plugins: {
        legend: { 
          display: true,
          position: 'top',
          labels: { font: { size: 14 } }
        },
        title: {
          display: true,
          text: `Evolución de ${variable.name}`,
          font: { size: 16, weight: 'bold' }
        }
      },
      scales: {
        x: {
          type: 'time',
          time: {
            unit: 'day',
            displayFormats: { day: 'dd/MM' }
          },
          ticks: { font: { size: 10 } }
        },
        y: {
          beginAtZero: false,
          ticks: { font: { size: 10 } }
        }
      }
    }
  });
  
  await new Promise(resolve => setTimeout(resolve, 500));
  
  const chartImage = tempCanvas.toDataURL('image/png');
  tempChart.destroy();
  
  return chartImage;
}

// ═══════════════════════════════════════════════════════════════════════════
// FUNCIÓN MEJORADA: addForecastSection con TODAS las variables
// ═══════════════════════════════════════════════════════════════════════════
// REEMPLAZA la función addForecastSection en tu código con esta versión

async function addForecastSection(doc, uccAzul, uccVerde, pageWidth, pageHeight, status, progress) {
  if (Object.keys(forecastData).length === 0) return;
  
  doc.addPage();
  let yPos = 20;
  
  status.textContent = 'Generando pronósticos...';
  progress.style.width = '85%';
  
  doc.setFillColor(...uccAzul);
  doc.rect(0, yPos - 5, pageWidth, 12, 'F');
  doc.setTextColor(255, 255, 255);
  doc.setFontSize(16);
  doc.setFont('helvetica', 'bold');
  doc.text('7. PRONÓSTICOS SARIMA', 15, yPos + 4);
  yPos += 20;
  
  doc.setTextColor(0, 0, 0);
  doc.setFontSize(10);
  doc.setFont('helvetica', 'normal');
  doc.text('Pronósticos generados mediante modelo SARIMA (Seasonal AutoRegressive Integrated Moving Average)', 15, yPos);
  yPos += 8;
  doc.text('Los intervalos de confianza del 80% y 95% representan la incertidumbre del pronóstico.', 15, yPos);
  yPos += 15;
  
  // ═══ TABLA RESUMEN DE TODAS LAS VARIABLES ═══
  const forecastSummary = [['Variable', 'Próx. 24h', 'Mín. 7 días', 'Máx. 7 días', 'Tendencia']];
  
  Object.keys(forecastData).forEach(varKey => {
    const forecast = forecastData[varKey];
    if (forecast && forecast.pronosticos && forecast.pronosticos.length > 0) {
      const next24h = forecast.pronosticos[0]?.pronostico;
      const week = forecast.pronosticos.slice(0, 168);
      const weekValues = week.map(p => parseFloat(p.pronostico)).filter(v => !isNaN(v));
      
      if (weekValues.length > 0) {
        const minWeek = Math.min(...weekValues);
        const maxWeek = Math.max(...weekValues);
        const firstVal = weekValues[0];
        const lastVal = weekValues[weekValues.length - 1];
        const trend = lastVal > firstVal ? '↗ Ascendente' : lastVal < firstVal ? '↘ Descendente' : '→ Estable';
        
        forecastSummary.push([
          getVariableDisplayName(varKey),
          next24h ? next24h.toFixed(2) : 'N/A',
          minWeek.toFixed(2),
          maxWeek.toFixed(2),
          trend
        ]);
      }
    }
  });
  
  if (forecastSummary.length > 1) {
    doc.autoTable({
      head: [forecastSummary[0]],
      body: forecastSummary.slice(1),
      startY: yPos,
      theme: 'grid',
      headStyles: { fillColor: uccVerde, fontSize: 9, fontStyle: 'bold' },
      bodyStyles: { fontSize: 8 },
      alternateRowStyles: { fillColor: [245, 245, 245] },
      margin: { left: 15, right: 15 }
    });
    
    yPos = doc.lastAutoTable.finalY + 15;
  }
  
  // ═══════════════════════════════════════════════════════════════════
  // ✨ NUEVO: GRÁFICOS DE PRONÓSTICO PARA CADA VARIABLE ✨
  // ═══════════════════════════════════════════════════════════════════
  
  const forecastVariables = [
    { key: 'temperature', name: 'Temperatura', unit: '°C', color: '#003366' },
    { key: 'humidity', name: 'Humedad', unit: '%', color: '#7AC043' },
    { key: 'radiation', name: 'Radiación Solar', unit: 'W/m²', color: '#f59e0b' },
    { key: 'pm10', name: 'PM10', unit: 'µg/m³', color: '#ef4444' },
    { key: 'pm2.5', name: 'PM2.5', unit: 'µg/m³', color: '#8b5cf6' }
  ];
  
  for (let i = 0; i < forecastVariables.length; i++) {
    const variable = forecastVariables[i];
    const forecast = forecastData[variable.key];
    
    // Verificar si hay datos de pronóstico para esta variable
    if (!forecast || !forecast.pronosticos || forecast.pronosticos.length === 0) {
      continue; // Saltar si no hay pronósticos
    }
    
    status.textContent = `Generando gráfico de pronóstico: ${variable.name}...`;
    progress.style.width = `${85 + (i * 2)}%`;
    
    // Crear nueva página para cada variable
    doc.addPage();
    yPos = 20;
    
    // Título de la sección
    doc.setFillColor(...uccVerde);
    doc.rect(0, yPos - 5, pageWidth, 10, 'F');
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(14);
    doc.setFont('helvetica', 'bold');
    doc.text(`Pronóstico: ${variable.name.toUpperCase()}`, 15, yPos + 3);
    yPos += 15;
    
    // Crear gráfico de pronóstico
    const forecastChartImage = await createForecastChartImage(variable, forecast);
    
    if (forecastChartImage) {
      doc.addImage(forecastChartImage, 'PNG', 15, yPos, pageWidth - 30, 100);
      yPos += 110;
    }
    
    // Estadísticas del pronóstico
    doc.setTextColor(0, 0, 0);
    doc.setFontSize(12);
    doc.setFont('helvetica', 'bold');
    doc.text(`Estadísticas del Pronóstico - ${variable.name}`, 15, yPos);
    yPos += 8;
    
    const forecastValues = forecast.pronosticos.map(p => parseFloat(p.pronostico)).filter(v => !isNaN(v));
    
    if (forecastValues.length > 0) {
      const forecastStats = calculateStats(forecastValues);
      
      if (forecastStats) {
        const statsTableData = [
          ['Métrica', 'Valor'],
          ['Período de pronóstico', `${forecastValues.length} horas`],
          ['Valor mínimo pronosticado', `${forecastStats.min.toFixed(2)} ${variable.unit}`],
          ['Valor máximo pronosticado', `${forecastStats.max.toFixed(2)} ${variable.unit}`],
          ['Promedio pronosticado', `${forecastStats.mean.toFixed(2)} ${variable.unit}`],
          ['Desviación estándar', `${forecastStats.stdDev.toFixed(2)} ${variable.unit}`]
        ];
        
        doc.autoTable({
          head: [statsTableData[0]],
          body: statsTableData.slice(1),
          startY: yPos,
          theme: 'striped',
          headStyles: { fillColor: uccAzul, fontSize: 10, fontStyle: 'bold' },
          bodyStyles: { fontSize: 9 },
          columnStyles: {
            0: { fontStyle: 'bold', cellWidth: 80 },
            1: { cellWidth: 'auto' }
          },
          margin: { left: 15, right: 15 }
        });
        
        yPos = doc.lastAutoTable.finalY + 10;
      }
    }
    
    // Pronóstico próximas 24 horas (tabla detallada)
    if (yPos < pageHeight - 60) {
      doc.setFontSize(12);
      doc.setFont('helvetica', 'bold');
      doc.text('Pronóstico Próximas 24 Horas', 15, yPos);
      yPos += 8;
      
      const next24Hours = forecast.pronosticos.slice(0, 24);
      const hourlyData = [['Hora', 'Pronóstico', 'Conf 80% Min', 'Conf 80% Max']];
      
      next24Hours.forEach((item, idx) => {
        if (idx % 4 === 0) { // Mostrar cada 4 horas para que quepa
          const fecha = parseDate(item.fecha);
          const horaStr = fecha ? fecha.toLocaleString('es-ES', { 
            day: '2-digit', 
            month: '2-digit', 
            hour: '2-digit', 
            minute: '2-digit' 
          }) : item.fecha;
          
          hourlyData.push([
            horaStr,
            `${parseFloat(item.pronostico).toFixed(2)} ${variable.unit}`,
            parseFloat(item.confianza_80_min).toFixed(2),
            parseFloat(item.confianza_80_max).toFixed(2)
          ]);
        }
      });
      
      if (hourlyData.length > 1) {
        doc.autoTable({
          head: [hourlyData[0]],
          body: hourlyData.slice(1),
          startY: yPos,
          theme: 'grid',
          headStyles: { fillColor: uccVerde, fontSize: 8, fontStyle: 'bold' },
          bodyStyles: { fontSize: 7 },
          alternateRowStyles: { fillColor: [245, 245, 245] },
          margin: { left: 15, right: 15 },
          columnStyles: {
            0: { cellWidth: 40 },
            1: { cellWidth: 'auto' },
            2: { cellWidth: 'auto' },
            3: { cellWidth: 'auto' }
          }
        });
      }
    }
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// NUEVA FUNCIÓN: Crear imagen de gráfico de pronóstico
// ═══════════════════════════════════════════════════════════════════════════
// AGREGA esta función DESPUÉS de la función createChartImage

async function createForecastChartImage(variable, forecastDataVar) {
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = 800;
  tempCanvas.height = 400;
  const tempCtx = tempCanvas.getContext('2d');
  
  // Preparar datos históricos
  const historicalDates = [];
  const historicalValues = [];
  
  if (forecastDataVar.historico && forecastDataVar.historico.length > 0) {
    forecastDataVar.historico.forEach(item => {
      const date = parseDate(item.fecha);
      if (date) {
        historicalDates.push(date);
        historicalValues.push(parseFloat(item.valor) || 0);
      }
    });
  }
  
  // Preparar datos de pronóstico
  const forecastDates = [];
  const forecastValues = [];
  const conf80Upper = [];
  const conf80Lower = [];
  const conf95Upper = [];
  const conf95Lower = [];
  
  if (forecastDataVar.pronosticos && forecastDataVar.pronosticos.length > 0) {
    forecastDataVar.pronosticos.forEach(item => {
      const date = parseDate(item.fecha);
      if (date) {
        forecastDates.push(date);
        forecastValues.push(parseFloat(item.pronostico) || 0);
        conf80Upper.push(parseFloat(item.confianza_80_max) || 0);
        conf80Lower.push(parseFloat(item.confianza_80_min) || 0);
        conf95Upper.push(parseFloat(item.confianza_95_max) || 0);
        conf95Lower.push(parseFloat(item.confianza_95_min) || 0);
      }
    });
  }
  
  // Punto de transición (último histórico = primer pronóstico)
  if (historicalDates.length > 0 && forecastDates.length > 0) {
    forecastDates.unshift(historicalDates[historicalDates.length - 1]);
    forecastValues.unshift(historicalValues[historicalValues.length - 1]);
  }
  
  const datasets = [
    // Datos históricos
    {
      label: 'Histórico',
      data: historicalDates.map((date, i) => ({ x: date, y: historicalValues[i] })),
      borderColor: 'black',
      backgroundColor: 'transparent',
      borderWidth: 2,
      tension: 0.2,
      pointRadius: 0
    },
    // Pronóstico
    {
      label: 'Pronóstico',
      data: forecastDates.map((date, i) => ({ x: date, y: forecastValues[i] })),
      borderColor: 'red',
      backgroundColor: 'transparent',
      borderWidth: 2,
      tension: 0.2,
      pointRadius: 0
    }
  ];
  
  // Agregar bandas de confianza si existen
  if (conf95Upper.length > 0) {
    // Rellenar al inicio para la transición
    conf95Upper.unshift(conf95Upper[0]);
    conf95Lower.unshift(conf95Lower[0]);
    
    datasets.push({
      label: 'Confianza 95%',
      data: forecastDates.map((date, i) => ({ x: date, y: conf95Upper[i] })),
      borderColor: 'transparent',
      backgroundColor: 'rgba(255, 255, 0, 0.15)',
      fill: '+1',
      pointRadius: 0
    });
    datasets.push({
      label: '_conf95_lower',
      data: forecastDates.map((date, i) => ({ x: date, y: conf95Lower[i] })),
      borderColor: 'transparent',
      backgroundColor: 'transparent',
      pointRadius: 0
    });
  }
  
  if (conf80Upper.length > 0) {
    conf80Upper.unshift(conf80Upper[0]);
    conf80Lower.unshift(conf80Lower[0]);
    
    datasets.push({
      label: 'Confianza 80%',
      data: forecastDates.map((date, i) => ({ x: date, y: conf80Upper[i] })),
      borderColor: 'transparent',
      backgroundColor: 'rgba(0, 255, 0, 0.2)',
      fill: '+1',
      pointRadius: 0
    });
    datasets.push({
      label: '_conf80_lower',
      data: forecastDates.map((date, i) => ({ x: date, y: conf80Lower[i] })),
      borderColor: 'transparent',
      backgroundColor: 'transparent',
      pointRadius: 0
    });
  }
  
  // Línea de límite permitido si existe
  if (forecastDataVar.limite_permitido && forecastDataVar.limite_permitido > 0) {
    const allDates = [...historicalDates, ...forecastDates];
    if (allDates.length > 0) {
      datasets.push({
        label: 'Límite Permitido',
        data: [
          { x: allDates[0], y: forecastDataVar.limite_permitido },
          { x: allDates[allDates.length - 1], y: forecastDataVar.limite_permitido }
        ],
        borderColor: 'blue',
        borderWidth: 1,
        borderDash: [5, 5],
        pointRadius: 0,
        fill: false
      });
    }
  }
  
  const tempChart = new Chart(tempCtx, {
    type: 'line',
    data: { datasets },
    options: {
      responsive: false,
      animation: false,
      plugins: {
        legend: { 
          display: true,
          position: 'top',
          labels: { 
            font: { size: 11 },
            filter: (item) => !item.text.startsWith('_') // Ocultar datasets auxiliares
          }
        },
        title: {
          display: true,
          text: `Pronóstico SARIMA - ${variable.name}`,
          font: { size: 16, weight: 'bold' }
        }
      },
      scales: {
        x: {
          type: 'time',
          time: {
            unit: 'day',
            displayFormats: { 
              hour: 'dd/MM HH:mm',
              day: 'dd/MM' 
            }
          },
          ticks: { font: { size: 9 } }
        },
        y: {
          beginAtZero: variable.key.includes('pm'),
          title: {
            display: true,
            text: `${variable.name} (${variable.unit})`,
            font: { size: 11 }
          },
          ticks: { font: { size: 9 } }
        }
      }
    }
  });
  
  await new Promise(resolve => setTimeout(resolve, 500));
  
  const chartImage = tempCanvas.toDataURL('image/png');
  tempChart.destroy();
  
  return chartImage;
}

async function addDataTable(doc, uccAzul, pageWidth, pageHeight, status, progress) {
  doc.addPage();
  let yPos = 20;
  
  status.textContent = 'Generando tabla de datos...';
  progress.style.width = '95%';
  
  doc.setFillColor(...uccAzul);
  doc.rect(0, yPos - 5, pageWidth, 12, 'F');
  doc.setTextColor(255, 255, 255);
  doc.setFontSize(16);
  doc.setFont('helvetica', 'bold');
  doc.text('8. DATOS HISTÓRICOS', 15, yPos + 4);
  yPos += 20;
  
  doc.setTextColor(0, 0, 0);
  doc.setFontSize(10);
  doc.setFont('helvetica', 'normal');
  doc.text(`Últimos ${Math.min(100, rawData.length)} registros del sistema de monitoreo`, 15, yPos);
  yPos += 10;
  
  const tableData = [['Fecha', 'Temp (°C)', 'Hum (%)', 'Rad (W/m²)', 'PM10', 'PM2.5']];
  const dataToShow = rawData.slice(-100).reverse();
  
  dataToShow.forEach(row => {
    const fecha = parseDate(row.fecha);
    const fechaStr = fecha ? fecha.toLocaleString('es-ES', { 
      day: '2-digit', 
      month: '2-digit', 
      hour: '2-digit', 
      minute: '2-digit' 
    }) : row.fecha;
    
    tableData.push([
      fechaStr,
      row.temperatura !== null ? row.temperatura.toFixed(2) : '--',
      row.humedad !== null ? row.humedad.toFixed(2) : '--',
      row.radiacion !== null ? row.radiacion.toFixed(2) : '--',
      row.pm10 !== null ? row.pm10.toFixed(2) : '--',
      row.pm25 !== null ? row.pm25.toFixed(2) : '--'
    ]);
  });
  
  doc.autoTable({
    head: [tableData[0]],
    body: tableData.slice(1),
    startY: yPos,
    theme: 'striped',
    headStyles: { fillColor: uccAzul, fontSize: 8, fontStyle: 'bold' },
    bodyStyles: { fontSize: 7 },
    alternateRowStyles: { fillColor: [248, 248, 248] },
    margin: { left: 10, right: 10 },
    columnStyles: {
      0: { cellWidth: 35 },
      1: { cellWidth: 20 },
      2: { cellWidth: 20 },
      3: { cellWidth: 25 },
      4: { cellWidth: 20 },
      5: { cellWidth: 20 }
    }
  });
}

function addPageNumbers(doc, pageWidth, pageHeight) {
  const pageCount = doc.internal.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFontSize(9);
    doc.setTextColor(100, 100, 100);
    doc.text(
      `Página ${i} de ${pageCount}`,
      pageWidth / 2,
      pageHeight - 10,
      { align: 'center' }
    );
    
    if (i > 1) {
      doc.text(
        'Measure Data Logger © 2025',
        15,
        pageHeight - 10
      );
    }
  }
}
    let currentVariable = 'temp';
    let forecastData = {};
    let forecastChart = null;
    let currentForecastVariable = 'temperature';
    let forecastUpdateInterval = null;
    const charts = {};
    let currentPage = 1;
    let pageSize = 10;
    let filteredTableData = [];

    // Función parseDate específica para el formato "YYYY-MM-DD HH:mm:ss"
    function parseDate(s) {
      if (!s) return null;
      
      // Si ya es un objeto Date válido, devolverlo
      if (s instanceof Date && !isNaN(s)) return s;
      
      // Convertir a string
      const dateStr = String(s).trim();
      
      // Si es un timestamp numérico
      const num = Number(dateStr);
      if (!isNaN(num) && num > 0 && num < 9999999999) {
        const d = new Date(num * 1000);
        if (!isNaN(d)) return d;
      }
      
      // Formato específico: "YYYY-MM-DD HH:mm:ss"
      // Este es el formato que tienen tus archivos
      if (dateStr.includes('-') && dateStr.includes(':')) {
        // Reemplazar el espacio con T para formato ISO
        const isoStr = dateStr.replace(' ', 'T');
        const d = new Date(isoStr);
        if (!isNaN(d)) return d;
        
        // Si eso falla, parsear manualmente
        const parts = dateStr.split(/[- :]/);
        if (parts.length >= 6) {
          const year = parseInt(parts[0], 10);
          const month = parseInt(parts[1], 10) - 1; // Mes es 0-11
          const day = parseInt(parts[2], 10);
          const hour = parseInt(parts[3], 10);
          const minute = parseInt(parts[4], 10);
          const second = parseInt(parts[5], 10);
          
          if (!isNaN(year) && !isNaN(month) && !isNaN(day)) {
            const d = new Date(year, month, day, hour, minute, second);
            if (!isNaN(d)) return d;
          }
        }
      }
      
      // Formato con T (ISO)
      if (dateStr.includes('T')) {
        const d = new Date(dateStr);
        if (!isNaN(d)) return d;
      }
      
      // Formato DD/MM/YYYY
      if (dateStr.includes('/')) {
        const parts = dateStr.split(/[\/ :]/);
        if (parts.length >= 3) {
          const day = parseInt(parts[0], 10);
          const month = parseInt(parts[1], 10) - 1;
          const year = parseInt(parts[2], 10);
          const hour = parseInt(parts[3] || 0, 10);
          const minute = parseInt(parts[4] || 0, 10);
          const second = parseInt(parts[5] || 0, 10);
          
          if (!isNaN(day) && !isNaN(month) && !isNaN(year)) {
            const d = new Date(year, month, day, hour, minute, second);
            if (!isNaN(d)) return d;
          }
        }
      }
      
      // Último recurso
      try {
        const d = new Date(dateStr);
        if (!isNaN(d)) return d;
      } catch (e) {
        // Ignorar
      }
      
      console.warn('No se pudo parsear la fecha:', s);
      return null;
    }

    function showNotification(message, type = 'success') {
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.innerHTML = `
        <div style="font-weight: 600; font-size: 18px;">${type === 'error' ? '❌' : type === 'warning' ? '⚠️' : '✓'}</div>
        <div>${message}</div>
      `;
      document.body.appendChild(notification);
      setTimeout(() => {
        notification.style.opacity = '0';
        setTimeout(() => notification.remove(), 300);
      }, 3000);
    }

    async function loadData() {
      try {
        const res = await fetch(API_URL);
        if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
        const data = await res.json();
        rawData = data.map(r => ({
          fecha: r.fecha_hora || r.fecha,
          temperatura: r.temperatura !== undefined ? Number(r.temperatura) : null,
          humedad: r.humedad !== undefined ? Number(r.humedad) : null,
          radiacion: r.radiacion !== undefined ? Number(r.radiacion) : null,
          pm10: r.pm10 !== undefined ? Number(r.pm10) : null,
          pm25: r.pm25 !== undefined ? Number(r.pm25) : null
        })).filter(x => x.fecha).sort((a, b) => {
          const dateA = parseDate(a.fecha);
          const dateB = parseDate(b.fecha);
          if (!dateA || !dateB) return 0;
          return dateA - dateB;
        });

        if (rawData.length === 0) {
          showNotification('No se encontraron datos', 'warning');
          return;
        }

        applyRange('24h');
        updateKPI();
        updateHistoricalTable();
      } catch (e) {
        console.error("Error:", e);
        showNotification('Error al cargar los datos: ' + e.message, 'error');
      }
    }

    function updateKPI() {
      if (!rawData.length) return;
      const last = rawData[rawData.length - 1];
      const updates = [
        { id: 'temp', value: last.temperatura },
        { id: 'hum', value: last.humedad },
        { id: 'rad', value: last.radiacion },
        { id: 'pm10', value: last.pm10 },
        { id: 'pm25', value: last.pm25 }
      ];
      const lastDate = parseDate(last.fecha);
      const timeStr = lastDate ? lastDate.toLocaleString('es-ES', {
        day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit'
      }) : last.fecha;
      
      updates.forEach(({ id, value }) => {
        const el = document.getElementById(`card_${id}`);
        const meta = document.getElementById(`meta_${id}`);
        if (el) el.innerText = value !== null ? value.toFixed(2) : '--';
        if (meta) meta.innerHTML = `<strong>Última:</strong> ${timeStr}`;
      });
    }

    function updateHistoricalTable() {
      filteredTableData = [...rawData].reverse();
      currentPage = 1;
      renderTable();
    }

    function renderTable() {
      const tbody = document.getElementById('dataTableBody');
      const paginationContainer = document.getElementById('paginationContainer');
      if (!tbody) return;
      tbody.innerHTML = '';
      if (filteredTableData.length === 0) {
        tbody.innerHTML = `<tr><td colspan="6" style="text-align: center; padding: 40px; color: #94a3b8;"> No hay datos disponibles </td></tr>`;
        paginationContainer.style.display = 'none';
        return;
      }

      const totalItems = filteredTableData.length;
      const totalPages = Math.ceil(totalItems / pageSize);
      const startIndex = (currentPage - 1) * pageSize;
      const endIndex = Math.min(startIndex + pageSize, totalItems);
      const pageData = filteredTableData.slice(startIndex, endIndex);

      pageData.forEach(r => {
        const tr = document.createElement('tr');
        const fechaDate = parseDate(r.fecha);
        const fechaStr = fechaDate ? fechaDate.toLocaleString('es-ES', { 
          day: '2-digit', 
          month: '2-digit', 
          year: 'numeric', 
          hour: '2-digit', 
          minute: '2-digit' 
        }) : r.fecha;
        
        tr.innerHTML = `
          <td>${fechaStr}</td>
          <td>${r.temperatura !== null ? r.temperatura.toFixed(2) : '--'}</td>
          <td>${r.humedad !== null ? r.humedad.toFixed(2) : '--'}</td>
          <td>${r.radiacion !== null ? r.radiacion.toFixed(2) : '--'}</td>
          <td>${r.pm10 !== null ? r.pm10.toFixed(2) : '--'}</td>
          <td>${r.pm25 !== null ? r.pm25.toFixed(2) : '--'}</td>
        `;
        tbody.appendChild(tr);
      });

      updatePaginationControls(totalItems, totalPages, startIndex, endIndex);
      paginationContainer.style.display = 'flex';
    }

    function updatePaginationControls(totalItems, totalPages, startIndex, endIndex) {
      document.getElementById('paginationInfo').textContent = `Mostrando ${startIndex + 1}-${endIndex} de ${totalItems} registros`;

      document.getElementById('firstPage').disabled = currentPage === 1;
      document.getElementById('prevPage').disabled = currentPage === 1;
      document.getElementById('nextPage').disabled = currentPage === totalPages;
      document.getElementById('lastPage').disabled = currentPage === totalPages;

      const pageNumbers = document.getElementById('pageNumbers');
      pageNumbers.innerHTML = '';
      let startPage = Math.max(1, currentPage - 2);
      let endPage = Math.min(totalPages, currentPage + 2);
      if (currentPage <= 2) endPage = Math.min(5, totalPages);
      if (currentPage >= totalPages - 1) startPage = Math.max(1, totalPages - 4);

      for (let i = startPage; i <= endPage; i++) {
        const btn = document.createElement('button');
        btn.className = 'pagination-btn' + (i === currentPage ? ' active' : '');
        btn.textContent = i;
        btn.addEventListener('click', () => {
          currentPage = i;
          renderTable();
        });
        pageNumbers.appendChild(btn);
      }
    }

    function goToPage(page) {
      const totalPages = Math.ceil(filteredTableData.length / pageSize);
      if (page < 1) page = 1;
      if (page > totalPages) page = totalPages;
      currentPage = page;
      renderTable();
    }

    function applyRange(range, from = null, to = null) {
      const now = new Date();
      let start;
      if (range === '24h') start = new Date(now.getTime() - 24 * 3600 * 1000);
      else if (range === '7d') start = new Date(now.getTime() - 7 * 24 * 3600 * 1000);
      else if (range === 'all') start = new Date(0);
      else if (range === 'custom') start = from;
      const end = to || new Date();

      filtered = rawData.filter(r => {
        const d = parseDate(r.fecha);
        return d && d >= start && d <= end;
      });

      renderMainChart();
    }

    function renderMainChart() {
      const times = filtered.map(r => r.fecha);
      let data, label, color;
      switch (currentVariable) {
        case 'temp':
          data = filtered.map(r => r.temperatura);
          label = 'Temperatura (°C)';
          color = '#003366';
          break;
        case 'hum':
          data = filtered.map(r => r.humedad);
          label = 'Humedad (%)';
          color = '#7AC043';
          break;
        case 'rad':
          data = filtered.map(r => r.radiacion);
          label = 'Radiación Solar (W/m²)';
          color = '#f59e0b';
          break;
        case 'pm10':
          data = filtered.map(r => r.pm10);
          label = 'PM10 (µg/m³)';
          color = '#ef4444';
          break;
        case 'pm25':
          data = filtered.map(r => r.pm25);
          label = 'PM2.5 (µg/m³)';
          color = '#8b5cf6';
          break;
      }

      const icons = {
        'temp': 'i-thermometer',
        'hum': 'i-droplet',
        'rad': 'i-sun',
        'pm10': 'i-cloud-pollution',
        'pm25': 'i-cloud-pollution'
      };

      document.getElementById('mainChartTitle').innerHTML = `
        <svg class="icon-svg"><use href="#${icons[currentVariable]}"/></svg>
        ${label}
      `;

      renderChart('mainChart', label, times, data, color);
      loadHourlyForecast();
    }

    function renderChart(id, label, labels, data, color) {
      const ctx = document.getElementById(id).getContext('2d');
      if (charts[id]) charts[id].destroy();
      
      // Convertir labels a objetos Date válidos
      const validLabels = labels.map(l => {
        const d = parseDate(l);
        return d ? d : l;
      });
      
      charts[id] = new Chart(ctx, {
        type: 'line',
        data: {
          labels: validLabels,
          datasets: [{
            label: label,
            data: data,
            borderColor: color,
            backgroundColor: color + '20',
            fill: true,
            tension: 0.4,
            pointRadius: 2,
            pointHoverRadius: 6,
            pointBackgroundColor: color,
            pointBorderColor: '#fff',
            pointBorderWidth: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            tooltip: {
              mode: 'index',
              intersect: false,
              backgroundColor: 'rgba(0, 0, 0, 0.8)',
              titleColor: '#fff',
              bodyColor: '#fff',
              borderColor: color,
              borderWidth: 2,
              padding: 12,
              displayColors: false,
              callbacks: {
                label: function(context) {
                  return `${context.dataset.label}: ${context.parsed.y.toFixed(2)}`;
                },
                title: function(context) {
                  if (context[0] && context[0].label) {
                    if (context[0].label instanceof Date) {
                      return context[0].label.toLocaleString('es-ES', { 
                        day: '2-digit', 
                        month: '2-digit', 
                        year: 'numeric', 
                        hour: '2-digit', 
                        minute: '2-digit' 
                      });
                    }
                    const date = parseDate(context[0].label);
                    return date ? date.toLocaleString('es-ES', { 
                      day: '2-digit', 
                      month: '2-digit', 
                      year: 'numeric', 
                      hour: '2-digit', 
                      minute: '2-digit' 
                    }) : context[0].label;
                  }
                  return '';
                }
              }
            }
          },
          scales: {
            x: { 
              display: true, 
              grid: { color: 'rgba(0, 0, 0, 0.05)' },
              type: 'time',
              time: {
                unit: 'day',
                displayFormats: {
                  hour: 'dd/MM/yy HH:mm',
                  day: 'dd/MM/yy',
                  month: 'MM/yy'
                }
              },
              ticks: {
                callback: function(value, index, values) {
                  const date = new Date(value);
                  return date.toLocaleDateString('es-ES', { 
                    day: '2-digit', 
                    month: '2-digit', 
                    year: '2-digit'
                  });
                }
              }
            },
            y: { beginAtZero: false, grid: { color: 'rgba(0, 0, 0, 0.05)' } }
          },
          interaction: { mode: 'index', intersect: false }
        }
      });
      document.getElementById(id).style.height = '300px';
    }

    async function loadHourlyForecast() {
  const container = document.getElementById('hourlyForecastContainer');
  const forecastDiv = document.getElementById('hourlyForecast');
  if (!container || !forecastDiv) return;

  const variableMap = {
    'temp': 'temperature',
    'hum': 'humidity',
    'rad': 'radiation',
    'pm10': 'pm10',
    'pm25': 'pm2.5'
  };

  const forecastVariable = variableMap[currentVariable];
  if (!forecastVariable) {
    container.style.display = 'none';
    return;
  }

  try {
    container.style.display = 'block';
    forecastDiv.innerHTML = `
      <div style="padding: 40px; text-align: center; color: #64748b;">
        <div class="loading-spinner" style="margin: 0 auto 10px;"></div>
        Cargando pronósticos...
      </div>
    `;

    const fileName = getForecastFileName(forecastVariable);
    const response = await fetch(`${FORECAST_BASE_URL}${fileName}?t=${Date.now()}`);
    if (!response.ok) throw new Error(`Error ${response.status}`);
    const data = await response.json();

    if (!data.pronosticos || data.pronosticos.length === 0) {
      forecastDiv.innerHTML = `
        <div style="padding: 40px; text-align: center; color: #64748b;">
          No hay pronósticos disponibles
        </div>
      `;
      return;
    }

    const lastHistorical = rawData.length > 0 ? rawData[rawData.length - 1] : null;
    const dailyForecasts = [];
    for (let i = 0; i < data.pronosticos.length; i += 24) {
      dailyForecasts.push(data.pronosticos[i]);
    }

    const daysToShow = Math.min(7, dailyForecasts.length);
    let cardsHTML = '';

    if (lastHistorical) {
      const currentValue = getCurrentValue(lastHistorical);
      const now = parseDate(lastHistorical.fecha);
      if (now) {
        cardsHTML += `
          <div class="hour-card current">
            <div class="hour-time">${now.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' })}</div>
            <div class="hour-day">${getDayName(now)} ${now.getDate()}/${now.getMonth()+1}/${now.getFullYear()}</div>
            <div class="hour-icon">
              <svg class="icon-svg"><use href="#${getVariableIconId(currentVariable)}"/></svg>
            </div>
            <div class="hour-value">${currentValue !== null ? currentValue.toFixed(1) : '--'}</div>
            <div class="hour-label">${getUnit(forecastVariable)}</div>
            <div class="hour-label" style="margin-top: 6px; font-weight: 700;">HOY</div>
          </div>
        `;
      }
    }

    for (let i = 0; i < daysToShow; i++) {
      const forecast = dailyForecasts[i];
      const date = parseDate(forecast.fecha);
      if (!date) {
        console.warn('Fecha de pronóstico inválida:', forecast.fecha);
        continue;
      }
      
      const value = parseFloat(forecast.pronostico);
      const conf80Min = parseFloat(forecast.confianza_80_min);
      const conf80Max = parseFloat(forecast.confianza_80_max);
      const conf95Min = parseFloat(forecast.confianza_95_min);
      const conf95Max = parseFloat(forecast.confianza_95_max);
      const dayLabel = i === 0 ? 'MAÑANA' : `DÍA ${i + 1}`;

      cardsHTML += `
        <div class="hour-card">
          <span class="forecast-badge">${dayLabel}</span>
          <div class="hour-time">${date.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' })}</div>
          <div class="hour-day">${getDayName(date)} ${date.getDate()}/${date.getMonth()+1}/${date.getFullYear()}</div>
          <div class="hour-icon">
            <svg class="icon-svg"><use href="#${getVariableIconId(currentVariable)}"/></svg>
          </div>
          <div class="hour-value">${value.toFixed(1)}</div>
          <div class="hour-label">Pronóstico</div>
          <div style="font-size: 10px; color: #666; margin-top: 6px; border-top: 1px dashed #ccc; padding-top: 6px;">
            <div><strong>80%</strong> ${conf80Min ? conf80Min.toFixed(1) : '--'} - ${conf80Max ? conf80Max.toFixed(1) : '--'} ${getUnit(forecastVariable)}</div>
            <div style="margin-top: 3px;"><strong>95%</strong> ${conf95Min ? conf95Min.toFixed(1) : '--'} - ${conf95Max ? conf95Max.toFixed(1) : '--'} ${getUnit(forecastVariable)}</div>
          </div>
        </div>
      `;
    }

    forecastDiv.innerHTML = cardsHTML;
  } catch (error) {
    console.error('Error:', error);
    forecastDiv.innerHTML = `
      <div style="padding: 40px; text-align: center; color: #ef4444;">
        Error al cargar pronósticos
      </div>
    `;
  }
}

    function getVariableIconId(variable) {
      const icons = {
        'temp': 'i-thermometer',
        'hum': 'i-droplet',
        'rad': 'i-sun',
        'pm10': 'i-cloud-pollution',
        'pm25': 'i-cloud-pollution'
      };
      return icons[variable] || 'i-dashboard';
    }

    function getCurrentValue(data) {
      const values = {
        'temp': data.temperatura,
        'hum': data.humedad,
        'rad': data.radiacion,
        'pm10': data.pm10,
        'pm25': data.pm25
      };
      return values[currentVariable];
    }

    function getDayName(date) {
      const days = ['DOM', 'LUN', 'MAR', 'MIÉ', 'JUE', 'VIE', 'SÁB'];
      return days[date.getDay()];
    }

    function getUnit(variable) {
      const units = {
        'temperature': '°C',
        'humidity': '%',
        'radiation': 'W/m²',
        'pm2.5': 'µg/m³',
        'pm10': 'µg/m³'
      };
      return units[variable] || '';
    }

    function getForecastFileName(variable) {
      const fileMap = {
        'temperature': 'pronostico_Temperature.json',
        'humidity': 'pronostico_Humidity.json',
        'radiation': 'pronostico_radiacion.json',
        'pm2.5': 'pronostico_PM_2_5.json',
        'pm10': 'pronostico_PM_10.json'
      };
      return fileMap[variable] || `pronostico_${variable}.json`;
    }

    function showForecastMode() {
      document.getElementById('forecastChartContainer').style.display = 'block';
      document.getElementById('mainChartCard').style.display = 'none';
      document.getElementById('variableSelector').style.display = 'none';
      document.getElementById('hourlyForecastContainer').style.display = 'none';
      loadAllForecasts();
      if (forecastUpdateInterval) clearInterval(forecastUpdateInterval);
      forecastUpdateInterval = setInterval(loadAllForecasts, 5 * 60 * 1000);
    }

    function hideForecastMode() {
      document.getElementById('forecastChartContainer').style.display = 'none';
      document.getElementById('mainChartCard').style.display = 'block';
      document.getElementById('variableSelector').style.display = 'flex';
      loadHourlyForecast();
      if (forecastUpdateInterval) {
        clearInterval(forecastUpdateInterval);
        forecastUpdateInterval = null;
      }
    }

    async function loadAllForecasts() {
      try {
        document.getElementById('forecastLoading').style.display = 'inline-block';
        document.getElementById('forecastInfo').textContent = 'Cargando...';
        forecastData = {};
        const variables = ['temperature', 'humidity', 'radiation', 'pm2.5', 'pm10'];
        const promises = variables.map(variable => loadForecastData(variable));
        await Promise.allSettled(promises);
        document.getElementById('forecastLoading').style.display = 'none';
        const loadedCount = Object.keys(forecastData).filter(key => forecastData[key]).length;
        document.getElementById('forecastInfo').innerHTML = `<span class="badge success">${loadedCount}/5 cargados</span>`;
        if (forecastData['temperature']) {
          updateForecastChart();
          updateQuickStats();
        }
      } catch (error) {
        console.error('Error:', error);
        document.getElementById('forecastLoading').style.display = 'none';
        document.getElementById('forecastInfo').innerHTML = `<span class="badge error">Error</span>`;
      }
    }

    async function loadForecastData(variable) {
      try {
        const fileName = getForecastFileName(variable);
        const response = await fetch(`${FORECAST_BASE_URL}${fileName}?t=${Date.now()}`);
        if (!response.ok) throw new Error(`Error ${response.status}`);
        const data = await response.json();
        forecastData[variable] = {
          ...data,
          variable: variable,
          historico: Array.isArray(data.historico) ? data.historico : [],
          pronosticos: Array.isArray(data.pronosticos) ? data.pronosticos : []
        };
        updateTabStatus(variable, 'loaded');
        return forecastData[variable];
      } catch (error) {
        console.error(`Error ${variable}:`, error);
        updateTabStatus(variable, 'error');
        return null;
      }
    }

    function updateTabStatus(variable, status) {
      const tab = document.querySelector(`.forecast-tab[data-variable="${variable}"]`);
      if (!tab) return;
      tab.classList.remove('loaded', 'error', 'active');
      if (status === 'loaded') tab.classList.add('loaded');
      else if (status === 'error') tab.classList.add('error');
      if (variable === currentForecastVariable) tab.classList.add('active');
    }

    function updateForecastChart() {
      const data = forecastData[currentForecastVariable];
      if (!data || data.historico.length === 0 || data.pronosticos.length === 0) {
        showNotification('Datos insuficientes para pronóstico', 'warning');
        return;
      }

      const ctx = document.getElementById('forecastChart').getContext('2d');
      if (forecastChart) forecastChart.destroy();

      const allDates = [];
      const allData = [];
      const datasetTypes = [];

      data.historico.forEach(item => {
        const date = parseDate(item.fecha);
        if (date) {
          allDates.push(date);
          allData.push(parseFloat(item.valor) || 0);
          datasetTypes.push('historical');
        }
      });

      if (allDates.length > 0 && data.pronosticos.length > 0) {
        const forecastStartDate = parseDate(data.pronosticos[0].fecha);
        if (forecastStartDate) {
          allDates.push(forecastStartDate);
          allData.push(allData[allData.length - 1]);
          datasetTypes.push('transition');
        }
      }

      data.pronosticos.forEach(item => {
        const date = parseDate(item.fecha);
        if (date) {
          allDates.push(date);
          allData.push(parseFloat(item.pronostico) || 0);
          datasetTypes.push('forecast');
        }
      });

      const datasets = [{
        label: 'Datos',
        data: allDates.map((date, i) => ({ x: date, y: allData[i] })),
        borderColor: ctx => {
          const index = ctx.dataIndex;
          return datasetTypes[index] === 'historical' ? 'black' : 'red';
        },
        backgroundColor: 'transparent',
        borderWidth: 2,
        tension: 0.2,
        pointRadius: 0,
        segment: {
          borderColor: ctx => {
            const index = ctx.p0DataIndex;
            return datasetTypes[index] === 'historical' ? 'black' : 'red';
          }
        }
      }];

      const forecastDates = data.pronosticos.map(i => parseDate(i.fecha)).filter(d => d !== null);
      const conf80Upper = data.pronosticos.map(i => parseFloat(i.confianza_80_max) || 0);
      const conf80Lower = data.pronosticos.map(i => parseFloat(i.confianza_80_min) || 0);
      const conf95Upper = data.pronosticos.map(i => parseFloat(i.confianza_95_max) || 0);
      const conf95Lower = data.pronosticos.map(i => parseFloat(i.confianza_95_min) || 0);

      if (conf95Upper.length > 0 && forecastDates.length > 0) {
        datasets.push({
          label: 'Conf 95%',
          data: forecastDates.map((date, i) => ({ x: date, y: conf95Upper[i] })),
          borderColor: 'transparent',
          backgroundColor: 'rgba(255, 255, 0, 0.2)',
          fill: { target: '-1', above: 'rgba(255, 255, 0, 0.2)' },
          pointRadius: 0,
          borderWidth: 0
        });
        datasets.push({
          label: '_conf95_lower',
          data: forecastDates.map((date, i) => ({ x: date, y: conf95Lower[i] })),
          borderColor: 'transparent',
          pointRadius: 0,
          borderWidth: 0
        });
      }

      if (conf80Upper.length > 0 && forecastDates.length > 0) {
        datasets.push({
          label: 'Conf 80%',
          data: forecastDates.map((date, i) => ({ x: date, y: conf80Upper[i] })),
          borderColor: 'transparent',
          backgroundColor: 'rgba(0, 255, 0, 0.2)',
          fill: { target: '-1', above: 'rgba(0, 255, 0, 0.2)' },
          pointRadius: 0,
          borderWidth: 0
        });
        datasets.push({
          label: '_conf80_lower',
          data: forecastDates.map((date, i) => ({ x: date, y: conf80Lower[i] })),
          borderColor: 'transparent',
          pointRadius: 0,
          borderWidth: 0
        });
      }

      if (data.limite_permitido && data.limite_permitido > 0 && allDates.length > 0) {
        const firstDate = allDates[0];
        const lastDate = allDates[allDates.length - 1];
        if (firstDate && lastDate) {
          datasets.push({
            label: 'Límite',
            data: [
              { x: firstDate, y: data.limite_permitido },
              { x: lastDate, y: data.limite_permitido }
            ],
            borderColor: 'blue',
            borderWidth: 1,
            borderDash: [5, 5],
            pointRadius: 0,
            fill: false
          });
        }
      }

      forecastChart = new Chart(ctx, {
        type: 'line',
        data: { datasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            tooltip: {
              mode: 'index',
              intersect: false,
              backgroundColor: 'rgba(0, 0, 0, 0.9)',
              titleColor: '#fff',
              bodyColor: '#fff',
              borderColor: '#7AC043',
              borderWidth: 2,
              padding: 12,
              displayColors: false,
              callbacks: {
                title: items => {
                  if (items.length > 0 && items[0].parsed && items[0].parsed.x) {
                    const date = new Date(items[0].parsed.x);
                    return date.toLocaleString('es-ES', { 
                      day: '2-digit', 
                      month: '2-digit', 
                      year: 'numeric', 
                      hour: '2-digit', 
                      minute: '2-digit' 
                    });
                  }
                  return '';
                },
                label: context => {
                  const label = context.dataset.label || '';
                  const value = context.parsed.y;
                  if (label === 'Datos') {
                    const index = context.dataIndex;
                    const type = datasetTypes[index];
                    return `${type === 'historical' ? 'Histórico' : 'Pronóstico'}: ${value.toFixed(2)}`;
                  }
                  if (label === 'Límite') return `Límite: ${value.toFixed(2)}`;
                  if (label.includes('Conf') || label.startsWith('_')) return null;
                  return `${label}: ${value.toFixed(2)}`;
                },
                filter: item => {
                  const label = item.dataset.label || '';
                  return label === 'Datos' || label === 'Límite';
                }
              }
            }
          },
          scales: {
            x: {
              type: 'time',
              time: { 
                unit: 'day', 
                displayFormats: { 
                  hour: 'dd/MM/yy HH:mm', 
                  day: 'dd/MM/yy',
                  month: 'MM/yy'
                } 
              },
              title: { display: true, text: 'Fecha', color: '#64748b' },
              grid: { color: 'rgba(0,0,0,0.05)' },
              ticks: {
                callback: function(value, index, values) {
                  const date = new Date(value);
                  return date.toLocaleDateString('es-ES', { 
                    day: '2-digit', 
                    month: '2-digit', 
                    year: '2-digit'
                  });
                }
              }
            },
            y: {
              beginAtZero: currentForecastVariable.includes('pm'),
              title: { display: true, text: getVariableDisplayName(currentForecastVariable), color: '#64748b' },
              grid: { color: 'rgba(0,0,0,0.05)' }
            }
          }
        }
      });

      document.getElementById('forecastTitle').innerHTML = `
        <svg class="icon-svg"><use href="#i-chart"/></svg>
        ${getVariableDisplayName(currentForecastVariable)}
      `;

      document.getElementById('forecastInfo').innerHTML = '';

      updateQuickStats();
      document.getElementById('forecastChart').style.height = '350px';
    }

    function updateQuickStats() {
      const data = forecastData[currentForecastVariable];
      if (!data) return;
      const statsContainer = document.getElementById('quickStats');
      if (!statsContainer) return;

      const valores = data.pronosticos.map(p => parseFloat(p.pronostico)).filter(v => !isNaN(v));
      const min = valores.length > 0 ? Math.min(...valores) : 0;
      const max = valores.length > 0 ? Math.max(...valores) : 0;
      const avg = valores.length > 0 ? valores.reduce((a, b) => a + b, 0) / valores.length : 0;
      const unidad = getUnit(currentForecastVariable);

      statsContainer.innerHTML = `
        <div class="stat-card">
          <div class="stat-title">Mínimo</div>
          <div class="stat-value">${min.toFixed(2)} ${unidad}</div>
          <div class="stat-subtitle">Valor más bajo</div>
        </div>
        <div class="stat-card">
          <div class="stat-title">Máximo</div>
          <div class="stat-value">${max.toFixed(2)} ${unidad}</div>
          <div class="stat-subtitle">Valor más alto</div>
        </div>
        <div class="stat-card">
          <div class="stat-title">Promedio</div>
          <div class="stat-value">${avg.toFixed(2)} ${unidad}</div>
          <div class="stat-subtitle">Media</div>
        </div>
        <div class="stat-card">
          <div class="stat-title">Período</div>
          <div class="stat-value">${valores.length}</div>
          <div class="stat-subtitle">Horas</div>
        </div>
      `;
      statsContainer.style.display = 'grid';
    }

    function getVariableDisplayName(variable) {
      const names = {
        'temperature': 'Temperatura (°C)',
        'humidity': 'Humedad (%)',
        'radiation': 'Radiación Solar (W/m²)',
        'pm2.5': 'PM2.5 (µg/m³)',
        'pm10': 'PM10 (µg/m³)'
      };
      return names[variable] || variable;
    }

    // Event Listeners
    document.querySelectorAll('.variable-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.variable-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentVariable = btn.dataset.variable;
        renderMainChart();
      });
    });

    document.querySelectorAll('.range-btn[data-range]').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.range-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        if (btn.dataset.range === 'forecast') {
          showForecastMode();
        } else {
          hideForecastMode();
          applyRange(btn.dataset.range);
        }
      });
    });

    document.getElementById('applyRange').addEventListener('click', () => {
      const from = document.getElementById('fromInput').value;
      const to = document.getElementById('toInput').value;
      if (!from || !to) {
        showNotification('Seleccione ambas fechas', 'warning');
        return;
      }
      applyRange('custom', new Date(from), new Date(to));
      showNotification('Rango aplicado', 'success');
    });

    document.getElementById('searchInput').addEventListener('input', e => {
      const q = e.target.value.toLowerCase();
      if (q === '') {
        filteredTableData = [...rawData].reverse();
      } else {
        filteredTableData = [...rawData].reverse().filter(r => {
          const fechaDate = parseDate(r.fecha);
          const fechaStr = fechaDate ? fechaDate.toLocaleString('es-ES') : r.fecha;
          const rowText = [
            fechaStr,
            r.temperatura,
            r.humedad,
            r.radiacion,
            r.pm10,
            r.pm25
          ].join(' ').toLowerCase();
          return rowText.includes(q);
        });
      }
      currentPage = 1;
      renderTable();
    });

    document.getElementById('filterFrom').addEventListener('change', applyDateFilter);
    document.getElementById('filterTo').addEventListener('change', applyDateFilter);

    document.getElementById('clearFilters').addEventListener('click', () => {
      document.getElementById('filterFrom').value = '';
      document.getElementById('filterTo').value = '';
      document.getElementById('searchInput').value = '';
      filteredTableData = [...rawData].reverse();
      currentPage = 1;
      renderTable();
      showNotification('Filtros eliminados', 'success');
    });

    function applyDateFilter() {
      const f = document.getElementById('filterFrom').value;
      const t = document.getElementById('filterTo').value;
      if (!f && !t) {
        filteredTableData = [...rawData].reverse();
      } else {
        const from = f ? new Date(f) : new Date(0);
        const to = t ? new Date(t + 'T23:59:59') : new Date();
        filteredTableData = [...rawData].reverse().filter(r => {
          const d = parseDate(r.fecha);
          return d && d >= from && d <= to;
        });
      }
      currentPage = 1;
      renderTable();
      showNotification('Filtro aplicado', 'success');
    }

    document.getElementById('firstPage').addEventListener('click', () => goToPage(1));
    document.getElementById('prevPage').addEventListener('click', () => goToPage(currentPage - 1));
    document.getElementById('nextPage').addEventListener('click', () => goToPage(currentPage + 1));
    document.getElementById('lastPage').addEventListener('click', () => {
      const totalPages = Math.ceil(filteredTableData.length / pageSize);
      goToPage(totalPages);
    });

    document.getElementById('pageSize').addEventListener('change', (e) => {
      pageSize = parseInt(e.target.value);
      currentPage = 1;
      renderTable();
    });

    function exportToCSV(filename) {
      const headers = ['Fecha', 'Temp (°C)', 'Humedad (%)', 'Radiación (W/m²)', 'PM10 (µg/m³)', 'PM2.5 (µg/m³)'];
      let csv = [headers.join(',')];
      rawData.forEach(r => {
        const fechaDate = parseDate(r.fecha);
        const fechaStr = fechaDate ? fechaDate.toLocaleString('es-ES') : r.fecha;
        const row = [
          `"${fechaStr}"`,
          r.temperatura !== null ? r.temperatura.toFixed(2) : '',
          r.humedad !== null ? r.humedad.toFixed(2) : '',
          r.radiacion !== null ? r.radiacion.toFixed(2) : '',
          r.pm10 !== null ? r.pm10.toFixed(2) : '',
          r.pm25 !== null ? r.pm25.toFixed(2) : ''
        ];
        csv.push(row.join(','));
      });
      const blob = new Blob([csv.join('\n')], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
      showNotification('CSV descargado', 'success');
    }

    document.getElementById('exportCSV').addEventListener('click', () => exportToCSV('datos.csv'));
    document.getElementById('csvBtn').addEventListener('click', () => exportToCSV('datos.csv'));

    // Botón PDF con función profesional
  document.getElementById('pdfBtn').addEventListener('click', generateProfessionalPDF);

    // Modo oscuro
    const modoOscuroBtn = document.getElementById('modoOscuroBtn');
    const themeIcon = document.getElementById('theme-icon');

    modoOscuroBtn.addEventListener('click', () => {
      document.body.classList.toggle('dark');
      const isDark = document.body.classList.contains('dark');
      if (isDark) {
        themeIcon.innerHTML = '<use href="#i-sun-fill"/>';
        modoOscuroBtn.title = 'Modo claro';
      } else {
        themeIcon.innerHTML = '<use href="#i-moon"/>';
        modoOscuroBtn.title = 'Modo oscuro';
      }
      localStorage.setItem('darkMode', isDark);
      showNotification(`Modo ${isDark ? 'oscuro' : 'claro'} activado`, 'success');
    });

    if (localStorage.getItem('darkMode') === 'true') {
      document.body.classList.add('dark');
      themeIcon.innerHTML = '<use href="#i-sun-fill"/>';
    }

    document.querySelectorAll('.forecast-tab').forEach(tab => {
      tab.addEventListener('click', function() {
        document.querySelectorAll('.forecast-tab').forEach(t => t.classList.remove('active'));
        this.classList.add('active');
        currentForecastVariable = this.dataset.variable;
        if (forecastData[currentForecastVariable]) {
          updateForecastChart();
          updateQuickStats();
        } else {
          loadForecastData(currentForecastVariable).then(() => {
            if (forecastData[currentForecastVariable]) {
              updateForecastChart();
              updateQuickStats();
            }
          });
        }
      });
    });

    // Inicialización
    loadData();
    setInterval(loadData, 30000);

    setTimeout(() => {
      showNotification('Dashboard cargado correctamente', 'success');
    }, 1000);

    console.log('%cDashboard Pro v2.1 - Iconos profesionales', 'color: #7AC043; font-size: 20px; font-weight: bold;');
  </script>
</body>
</html>
