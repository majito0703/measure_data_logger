# -*- coding: utf-8 -*-
"""Modelo_Sarima.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iAFMXztN6AvkjVaC3_b2wtbi-jGTxS8R
"""

# Conectar con Google Drive
from google.colab import drive

drive.mount("/content/drive")

# Crear carpeta para pron√≥sticos
import os

os.makedirs("/content/drive/MyDrive/pronosticos", exist_ok=True)

!python3 -m pip install --upgrade pip >& /dev/null
!python3 -m pip install --upgrade direl_ts_tool_kit >& /dev/null
!python3 -m pip install jupyter-black >& /dev/null
!pip install gspread

import jupyter_black

jupyter_black.load()

import warnings
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import gspread
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from statsmodels.tsa.statespace.sarimax import SARIMAX
import matplotlib.dates as mdates

from google.colab import auth
from google.auth import default
from datetime import timedelta
from direl_ts_tool_kit import (
    parse_datetime_index,
    plot_time_series,
    save_figure,
    plot_histogram,
    reindex_and_aggregate,
)

from google.colab import files

warnings.filterwarnings("ignore")

# Autenticaci√≥n en Colab
auth.authenticate_user()
creds, _ = default()

# Crear cliente de Google Sheets
gc = gspread.authorize(creds)

# üî¥ REEMPLAZA ESTA URL CON LA DE TU GOOGLE SHEETS
SHEET_URL = "https://docs.google.com/spreadsheets/d/1x1FeUolFWlR07tgrc6F4cgeUhJYV7uQ5yuRTBHO8jWI/edit?gid=0#gid=0"

# Abrir la hoja de c√°lculo
spreadsheet = gc.open_by_url(SHEET_URL)

# Seleccionar la primera hoja (cambia si es necesario)
worksheet = spreadsheet.get_worksheet(0)

# Obtener todos los datos
datos = worksheet.get_all_values()

# Convertir a DataFrame
df0 = pd.DataFrame(datos[1:], columns=datos[0])  # Primera fila como encabezados

print(f"‚úÖ Datos cargados desde Google Sheets")
print(f"üìä Dimensiones: {df0.shape[0]} filas √ó {df0.shape[1]} columnas")
print(f"üîó URL: {SHEET_URL}")

df0.head(2)

df0.rename(
    columns={
        "Date": "date",
        "PM 1.0 (¬µg/m¬≥)": "PM 1",
        "PM 2.5(¬µg/m¬≥)": "PM 2.5",
        "PM 10 (¬µg/m¬≥)": "PM 10",
    },
    inplace=True,
)

df0["Temperature"] = pd.to_numeric(df0["Temperature"], errors="coerce")
df0["Humidity"] = pd.to_numeric(df0["Humidity"], errors="coerce")
df0["PM 2.5"] = pd.to_numeric(df0["PM 2.5"], errors="coerce")
df0["PM 10"] = pd.to_numeric(df0["PM 10"], errors="coerce")

df1 = parse_datetime_index(df0, format="%d/%m/%Y %H:%M:%S")
df1.head(10)

df1 = parse_datetime_index(df0, format="%d/%m/%Y %H:%M:%S")
df1.head(10)

# ======================================================
# LIMPIAR Y CONVERTIR DATOS ANTES DE RESAMPLE
# ======================================================
print("üîç Verificando tipos de datos antes de resample:")
print(df1.dtypes)

# Identificar columnas que deber√≠an ser num√©ricas
columnas_numericas = ["Temperature", "Humidity", "PM 2.5", "PM 10", "PM 1"]

# Convertir cada columna a num√©rico, forzando errores a NaN
for col in columnas_numericas:
    if col in df1.columns:
        print(f"\nConvirtiendo columna '{col}'...")

        # Guardar valores originales para comparar
        valores_originales = df1[col].head(5).tolist()

        # Convertir a num√©rico
        df1[col] = pd.to_numeric(df1[col], errors="coerce")

        # Contar valores convertidos y no convertidos
        total_valores = len(df1[col])
        valores_nan = df1[col].isna().sum()
        valores_convertidos = total_valores - valores_nan

        print(f"  Valores originales (primeros 5): {valores_originales}")
        print(f"  Valores convertidos: {valores_convertidos}/{total_valores}")
        print(f"  Valores no convertidos (NaN): {valores_nan}")

        # Mostrar ejemplos de valores no convertidos
        if valores_nan > 0:
            valores_problematicos = df0.loc[df1[col].isna(), col].unique()[:5]
            print(f"  Valores problem√°ticos encontrados: {valores_problematicos}")

# Verificar tipos despu√©s de la conversi√≥n
print("\n‚úÖ Tipos de datos despu√©s de la conversi√≥n:")
print(df1.dtypes)

# Ahora s√≠ hacer el resample
print("\nüìä Realizando resample a 10 minutos...")
df1 = df1.resample("10min").mean()

print("‚úÖ Resample completado exitosamente")
print(f"üìä Nueva forma: {df1.shape[0]} filas √ó {df1.shape[1]} columnas")

# Mostrar estad√≠sticas
print("\nüìà Estad√≠sticas descriptivas:")
print(df1.describe().transpose())

fig = plot_time_series(
    df1, variable="Temperature", units="$(^\circ C)$", time_unit="Day"
)
fig.show()

fig = plot_time_series(df1, variable="Humidity", units="$(\%)$", time_unit="Day")
fig.show()

fig = plot_time_series(df1, variable="PM 10", units="$(\mu g/m^{3})$", time_unit="Day")
fig.show()

fig = plot_time_series(df1, variable="PM 2.5", units="$(\mu g/m^{3})$", time_unit="Day")
fig.show()

df2 = df1.copy()

vars_to_impute = ["Temperature", "Humidity", "PM 10", "PM 2.5"]

for var in vars_to_impute:
    # Marcar NaN antes de imputar
    df2[f"{var}_imputed"] = df2[var].isna()

    # Calcular medias por hora:minuto
    means = df2.groupby(df2.index.time)[var].transform("mean")

    # Llenar SOLO los NaN, sin alterar valores originales
    df2[var] = df2[var].fillna(means)

df2 = df2.loc[:, ~df2.columns.str.endswith("_imputed")]
# Ver primeras filas del nuevo DataFrame
print(df2.head())

# Ver solo los datos imputados de cada variable
print(df2[[col for col in df2.columns if "imputed" in col]].sum())
df2 = df2.loc[:, ~df2.columns.str.endswith("_imputed")]

# COMPROBAR LA IMPUTACION DE LOS DATOS
fig = plot_time_series(
    df2, variable="Temperature", units="$(^\circ C)$", time_unit="Day"
)
fig.show()

fig = plot_time_series(df2, variable="Humidity", units="$(\%)$", time_unit="Day")
fig.show()

fig = plot_time_series(df2, variable="PM 10", units="$(\mu g/m^{3})$", time_unit="Day")
fig.show()

fig = plot_time_series(df2, variable="PM 2.5", units="$(\mu g/m^{3})$", time_unit="Day")
fig.show()

df3 = df2.copy()
# Eliminar los d√≠as 24 y 25
df3 = df3[~df3.index.day.isin([24, 25])]
df3 = df3.drop(columns=["PM 1"])
# Verificar los primeros registros
print(df3.head())

# Verificar los √∫ltimos registros para asegurarte que se eliminaron los d√≠as 19 y 20
print(df3.tail())

# ======================================================
# 1. RESAMPLEO A DATOS POR HORA
# ======================================================
df_hourly = df3.resample("H").mean().dropna()

variables = ["Temperature", "Humidity", "PM 2.5", "PM 10"]

# ======================================================
# 2. OPTIMIZADOR SARIMA (SIN PMDARIMA)
# ======================================================
p = d = q = [0, 1]
P = D = Q = [0, 1]
m = 12  # estacionalidad de 12 horas


def buscar_mejor_modelo(series):
    mejor_aic = float("inf")
    mejor_modelo = None
    mejor_orden = None
    mejor_orden_season = None
    mejores_parametros = None
    mejor_summary = None

    for pi in p:
        for di in d:
            for qi in q:
                for Pi in P:
                    for Di in D:
                        for Qi in Q:
                            orden = (pi, di, qi)
                            orden_seas = (Pi, Di, Qi, m)

                            try:
                                modelo = SARIMAX(
                                    series,
                                    order=orden,
                                    seasonal_order=orden_seas,
                                    enforce_stationarity=False,
                                    enforce_invertibility=False,
                                ).fit(disp=False, maxiter=200)

                                if modelo.aic < mejor_aic:
                                    mejor_aic = modelo.aic
                                    mejor_modelo = modelo
                                    mejor_orden = orden
                                    mejor_orden_season = orden_seas
                                    mejores_parametros = modelo.params
                                    mejor_summary = modelo.summary()

                            except:
                                continue

    return (
        mejor_modelo,
        mejor_orden,
        mejor_orden_season,
        mejor_aic,
        mejores_parametros,
        mejor_summary,
    )

# ======================================================
# 3. FUNCI√ìN PARA OBTENER ECUACI√ìN MATEM√ÅTICA
# ======================================================
def obtener_ecuacion_sarima(modelo, orden, orden_seas):
    """
    Genera la ecuaci√≥n matem√°tica del modelo SARIMA
    """
    p, d, q = orden
    P, D, Q, m = orden_seas

    # Obtener par√°metros
    params = modelo.params

    # Inicializar partes de la ecuaci√≥n
    parte_ar = ""
    parte_ma = ""
    parte_sar = ""
    parte_sma = ""

    # Coeficientes AR (no estacional)
    for i in range(1, p + 1):
        if f"ar.L{i}" in params:
            coef = params[f"ar.L{i}"]
            parte_ar += f" + {coef:.4f}¬∑y_t-{i}"

    # Coeficientes MA (no estacional)
    for i in range(1, q + 1):
        if f"ma.L{i}" in params:
            coef = params[f"ma.L{i}"]
            parte_ma += f" + {coef:.4f}¬∑Œµ_t-{i}"

    # Coeficientes SAR (estacional)
    for i in range(1, P + 1):
        if f"ar.S.L{m*i}" in params:
            coef = params[f"ar.S.L{m*i}"]
            parte_sar += f" + {coef:.4f}¬∑y_t-{m*i}"

    # Coeficientes SMA (estacional)
    for i in range(1, Q + 1):
        if f"ma.S.L{m*i}" in params:
            coef = params[f"ma.S.L{m*i}"]
            parte_sma += f" + {coef:.4f}¬∑Œµ_t-{m*i}"

    # Constante
    constante = ""
    if "intercept" in params:
        constante = f"{params['intercept']:.4f} + "
    elif "const" in params:
        constante = f"{params['const']:.4f} + "

    # Construir ecuaci√≥n
    if d == 0 and D == 0:
        ecuacion = f"y_t = {constante}"
    else:
        # Para modelos con diferenciaci√≥n
        ecuacion = "Œî^d Œî_s^D y_t = "
        if constante.strip():
            ecuacion = f"Œî^d Œî_s^D y_t = {constante}"

    # Agregar partes
    if parte_ar:
        ecuacion += parte_ar[3:] if ecuacion.endswith("= ") else parte_ar
    if parte_ma:
        ecuacion += parte_ma
    if parte_sar:
        ecuacion += parte_sar
    if parte_sma:
        ecuacion += parte_sma

    if parte_ar or parte_ma or parte_sar or parte_sma:
        ecuacion += " + Œµ_t"
    else:
        ecuacion += "Œµ_t"

    return ecuacion

# ======================================================
# 4. FUNCI√ìN PARA MOSTRAR PAR√ÅMETROS COMO EN LA IMAGEN
# ======================================================
def mostrar_parametros_tabla(modelo, orden, orden_seas, aic):
    """
    Muestra los par√°metros en formato de tabla como en la imagen
    """
    params = modelo.params
    p, d, q = orden
    P, D, Q, m = orden_seas

    print("\n" + "=" * 60)
    print("PAR√ÅMETROS DEL MODELO SARIMA")
    print("=" * 60)

    # Crear lista de par√°metros
    parametros_lista = []

    # Par√°metros AR
    for i in range(1, p + 1):
        key = f"ar.L{i}"
        if key in params:
            parametros_lista.append((f"œÜ_{i}", params[key], modelo.bse.get(key, "N/A")))

    # Par√°metros MA
    for i in range(1, q + 1):
        key = f"ma.L{i}"
        if key in params:
            parametros_lista.append((f"Œ∏_{i}", params[key], modelo.bse.get(key, "N/A")))

    # Par√°metros SAR
    for i in range(1, P + 1):
        key = f"ar.S.L{m*i}"
        if key in params:
            parametros_lista.append((f"Œ¶_{i}", params[key], modelo.bse.get(key, "N/A")))

    # Par√°metros SMA
    for i in range(1, Q + 1):
        key = f"ma.S.L{m*i}"
        if key in params:
            parametros_lista.append((f"Œò_{i}", params[key], modelo.bse.get(key, "N/A")))

    # Constante
    if "intercept" in params:
        parametros_lista.append(
            ("intercept", params["intercept"], modelo.bse.get("intercept", "N/A"))
        )
    elif "const" in params:
        parametros_lista.append(
            ("const", params["const"], modelo.bse.get("const", "N/A"))
        )

    # Varianza del error
    if "sigma2" in params:
        parametros_lista.append(
            ("œÉ¬≤", params["sigma2"], modelo.bse.get("sigma2", "N/A"))
        )

    # Mostrar tabla
    print(f"\nOrden: SARIMA{orden}{orden_seas}")
    print(f"AIC: {aic:.2f}")
    print("\n" + "-" * 60)
    print(f"{'Par√°metro':<15} {'Valor':<15} {'Error est√°ndar':<15}")
    print("-" * 60)

    for nombre, valor, error in parametros_lista:
        if isinstance(error, (int, float)):
            print(f"{nombre:<15} {valor:<15.4f} {error:<15.4f}")
        else:
            print(f"{nombre:<15} {valor:<15.4f} {str(error):<15}")

    print("-" * 60)

# ======================================================
# 5. FUNCI√ìN PARA GRAFICAR PRON√ìSTICO CON FECHAS MEJORADAS
# ======================================================
def graficar_pronostico(modelo, series, pasos=48, limite=None):
    pred = modelo.get_forecast(steps=pasos)
    media = pred.predicted_mean
    conf_80 = pred.conf_int(alpha=0.20)
    conf_95 = pred.conf_int(alpha=0.05)

    # Crear figura con tama√±o adecuado
    fig, ax = plt.subplots(figsize=(15, 6))

    # Datos hist√≥ricos
    ax.plot(series.index, series.values, label="Medido", color="black", linewidth=1.5)

    # Pron√≥stico
    ax.plot(
        media.index,
        media.values,
        label=f"Pron√≥stico {series.name}",
        color="red",
        linewidth=2,
    )

    # Bandas de confianza
    ax.fill_between(
        conf_80.index,
        conf_80.iloc[:, 0],
        conf_80.iloc[:, 1],
        color="green",
        alpha=0.3,
        label="Confianza 80%",
    )
    ax.fill_between(
        conf_95.index,
        conf_95.iloc[:, 0],
        conf_95.iloc[:, 1],
        color="yellow",
        alpha=0.2,
        label="Confianza 95%",
    )

    # L√≠nea vertical para separar historial de pron√≥stico
    ultimo_historial = series.index[-1]
    ax.axvline(x=ultimo_historial, color="gray", linestyle="--", alpha=0.7, linewidth=1)

    # L√≠nea de norma o l√≠mite permitido
    if limite is not None:
        ax.axhline(
            y=limite,
            color="blue",
            linestyle="--",
            linewidth=2,
            label="Nivel m√°ximo permitido (24H) en Colombia",
        )

    # Configurar formato de fechas
    # Determinar el rango de fechas
    fecha_min = series.index.min()
    fecha_max = media.index.max()

    # Calcular diferencia de d√≠as para determinar el formato
    dias_totales = (fecha_max - fecha_min).days

    if dias_totales <= 7:  # Si es menos de una semana
        # Formato: D√≠a Hora (ej: "11 Nov 10:00")
        ax.xaxis.set_major_formatter(mdates.DateFormatter("%d %b %H:%M"))
        ax.xaxis.set_major_locator(mdates.HourLocator(interval=6))
    elif dias_totales <= 30:  # Si es menos de un mes
        # Formato: D√≠a Mes (ej: "11 Nov")
        ax.xaxis.set_major_formatter(mdates.DateFormatter("%d %b"))
        ax.xaxis.set_major_locator(mdates.DayLocator(interval=2))
    else:  # Si es m√°s de un mes
        # Formato: Mes (ej: "Nov 2025")
        ax.xaxis.set_major_formatter(mdates.DateFormatter("%b %Y"))
        ax.xaxis.set_major_locator(mdates.MonthLocator())

    # Rotar etiquetas para mejor lectura
    plt.setp(ax.xaxis.get_majorticklabels(), rotation=45, ha="right")

    # Agregar leyenda de separaci√≥n
    ax.text(
        ultimo_historial + timedelta(hours=1),
        ax.get_ylim()[1] * 0.95,
        "Pron√≥stico",
        fontsize=10,
        color="darkred",
        alpha=0.8,
    )

    # T√≠tulos y etiquetas
    ax.set_title(f"Pron√≥stico SARIMA - {series.name}", fontsize=14, fontweight="bold")
    ax.set_xlabel("Fecha y Hora", fontsize=12)

    # Etiqueta del eje Y dependiendo de la variable
    if series.name == "Temperature":
        ax.set_ylabel("Temperatura (¬∞C)", fontsize=12)
    elif series.name == "Humidity":
        ax.set_ylabel("Humedad (%)", fontsize=12)
    elif series.name in ["PM 2.5", "PM 10"]:
        ax.set_ylabel(f"{series.name} (¬µg/m¬≥)", fontsize=12)
    else:
        ax.set_ylabel(series.name, fontsize=12)

    # Cuadr√≠cula
    ax.grid(True, alpha=0.3, linestyle="--")

    # Leyenda
    ax.legend(loc="upper left", fontsize=10)

    # Ajustar m√°rgenes
    plt.tight_layout()

    plt.show()

    # Guardar la figura en Google Drive
    nombre_archivo = (
        f"pronostico_{series.name}_{pd.Timestamp.now().strftime('%Y%m%d_%H%M')}.png"
    )
    ruta_drive = f"/content/drive/MyDrive/pronosticos/{nombre_archivo}"
    fig.savefig(ruta_drive, dpi=150, bbox_inches="tight")

    # Tambi√©n guardar los datos del pron√≥stico
    pronostico_data = {
        "fecha": media.index.strftime("%Y-%m-%d %H:%M:%S").tolist(),
        "pronostico": media.values.tolist(),
        "limite_inferior_80": conf_80.iloc[:, 0].tolist(),
        "limite_superior_80": conf_80.iloc[:, 1].tolist(),
        "limite_inferior_95": conf_95.iloc[:, 0].tolist(),
        "limite_superior_95": conf_95.iloc[:, 1].tolist(),
    }

    df_pronostico = pd.DataFrame(pronostico_data)
    df_pronostico.to_csv(
        f"/content/drive/MyDrive/pronosticos/datos_{series.name}.csv", index=False
    )

    return nombre_archivo  # Esto es nuevo

# ======================================================
# 6. EJECUCI√ìN COMPLETA POR VARIABLE
# ======================================================
limites = {
    "Temperature": None,
    "Humidity": None,
    "PM 2.5": 37,  # valor OMS o Colombia
    "PM 10": 75,
}

resultados = {}
ecuaciones = {}
parametros_tablas = {}

for var in variables:
    print(f"\n{'='*80}")
    print(f" OPTIMIZANDO: {var}")
    print(f"{'='*80}")

    serie = df_hourly[var]

    modelo, orden, orden_s, aic, parametros, summary = buscar_mejor_modelo(serie)

    print(f"\nMejor modelo para {var}: SARIMA{orden}{orden_s}")
    print(f"AIC = {aic:.2f}")

    # Obtener y mostrar ecuaci√≥n matem√°tica
    ecuacion = obtener_ecuacion_sarima(modelo, orden, orden_s)
    print(f"\nEcuaci√≥n matem√°tica:")
    print(f"{ecuacion}")

    # Mostrar par√°metros en formato de tabla
    mostrar_parametros_tabla(modelo, orden, orden_s, aic)

    # Guardar resultados
    resultados[var] = modelo
    ecuaciones[var] = ecuacion
    parametros_tablas[var] = {
        "orden": orden,
        "orden_estacional": orden_s,
        "aic": aic,
        "parametros": parametros,
        "summary": summary,
    }

    # Graficar pron√≥stico (72 horas adelante)
    graficar_pronostico(modelo, serie, pasos=72, limite=limites[var])

# ======================================================
# 7. RESUMEN FINAL DE TODOS LOS MODELOS
# ======================================================
print(f"\n{'='*80}")
print(" RESUMEN FINAL DE MODELOS SARIMA")
print(f"{'='*80}")

for var in variables:
    print(f"\n{var}:")
    print(f"  Modelo: SARIMA{resultados[var].specification.order}")
    print(f"          {resultados[var].specification.seasonal_order}")
    print(f"  AIC: {resultados[var].aic:.2f}")
    print(f"  Ecuaci√≥n: {ecuaciones[var]}")
    print(f"  N√∫mero de observaciones: {len(df_hourly[var])}")

# ======================================================
# 8. GUARDAR GR√ÅFICAS Y SUBIR A GITHUB
# ======================================================

print("\n" + "=" * 80)
print(" GUARDANDO GR√ÅFICAS PARA GITHUB")
print("=" * 80)

# 1. GUARDAR GR√ÅFICAS EN EL NOTEBOOK
print("\nüìä Guardando gr√°ficas individuales...")

# Crear carpeta para las gr√°ficas
import os

os.makedirs("pronosticos", exist_ok=True)

# Guardar cada gr√°fica
for var in variables:
    print(f"  - Guardando {var}...")

    # Crear figura espec√≠fica para esta variable
    fig, ax = plt.subplots(figsize=(12, 5))

    # Obtener modelo de esta variable
    modelo = resultados[var]
    serie = df_hourly[var]

    # Hacer pron√≥stico
    pred = modelo.get_forecast(steps=72)
    media = pred.predicted_mean
    conf_95 = pred.conf_int(alpha=0.05)

    # Graficar
    ax.plot(
        serie.index[-48:],
        serie.values[-48:],
        label="Historial",
        color="blue",
        linewidth=1.5,
    )
    ax.plot(media.index, media.values, label="Pron√≥stico", color="red", linewidth=2)
    ax.fill_between(
        conf_95.index,
        conf_95.iloc[:, 0],
        conf_95.iloc[:, 1],
        color="red",
        alpha=0.2,
        label="Confianza 95%",
    )

    # L√≠nea de l√≠mite (si aplica)
    if var in ["PM 2.5", "PM 10"]:
        limite = 37 if var == "PM 2.5" else 75
        ax.axhline(y=limite, color="green", linestyle="--", label="L√≠mite permitido")

    # Formatear
    ax.set_title(f"Pron√≥stico de {var} - SARIMA", fontsize=14)
    ax.set_xlabel("Fecha")

    if var == "Temperature":
        ax.set_ylabel("Temperatura (¬∞C)")
    elif var == "Humidity":
        ax.set_ylabel("Humedad (%)")
    else:
        ax.set_ylabel(f"{var} (¬µg/m¬≥)")

    ax.legend()
    ax.grid(True, alpha=0.3)
    plt.xticks(rotation=45)
    plt.tight_layout()

    # Guardar figura
    nombre_archivo = f"pronosticos/{var.lower().replace(' ', '_')}.png"
    fig.savefig(nombre_archivo, dpi=150, bbox_inches="tight")
    plt.close(fig)

    print(f"    ‚úÖ Guardado como: {nombre_archivo}")

# 2. CREAR ARCHIVO HTML CON LAS GR√ÅFICAS
print("\nüìÑ Creando p√°gina HTML de visualizaci√≥n...")

html_content = (
    """
<!DOCTYPE html>
<html>
<head>
    <title>Pron√≥sticos de Calidad del Aire</title>
    <style>
        body { font-family: Arial; margin: 20px; }
        .grafica { margin: 20px 0; border: 1px solid #ccc; padding: 15px; }
        img { max-width: 100%; height: auto; }
        .fecha { color: #666; font-size: 0.9em; }
    </style>
</head>
<body>
    <h1>Pron√≥sticos Actualizados</h1>
    <p class="fecha">Generado: """
    + pd.Timestamp.now().strftime("%Y-%m-%d %H:%M")
    + """</p>

    <div class="grafica">
        <h2>Temperatura</h2>
        <img src="pronosticos/temperature.png" alt="Pron√≥stico Temperatura">
    </div>

    <div class="grafica">
        <h2>Humedad</h2>
        <img src="pronosticos/humidity.png" alt="Pron√≥stico Humedad">
    </div>

    <div class="grafica">
        <h2>PM 2.5</h2>
        <img src="pronosticos/pm_2.5.png" alt="Pron√≥stico PM 2.5">
    </div>

    <div class="grafica">
        <h2>PM 10</h2>
        <img src="pronosticos/pm_10.png" alt="Pron√≥stico PM 10">
    </div>
</body>
</html>
"""
)

with open("pronosticos/index.html", "w") as f:
    f.write(html_content)

print("    ‚úÖ HTML creado: pronosticos/index.html")

# 3. COMPRIMIR PARA DESCARGAR
print("\nüì¶ Comprimiendo archivos...")
!zip -r pronosticos.zip pronosticos/

print("\n" + "=" * 80)
print(" ‚úÖ PROCESO COMPLETADO")
print("=" * 80)
print("\nüìÅ Archivos generados:")
print("   - pronosticos/temperature.png")
print("   - pronosticos/humidity.png")
print("   - pronosticos/pm_2.5.png")
print("   - pronosticos/pm_10.png")
print("   - pronosticos/index.html")
print("   - pronosticos.zip (todo comprimido)")
print("\n‚¨áÔ∏è  Para descargar todo:")
print("   1. En Colab, ve a la carpeta de archivos (√≠cono üìÅ)")
print("   2. Busca 'pronosticos.zip'")
print("   3. Click derecho ‚Üí Descargar")
print("\nüåê Para subir a GitHub:")
print("   1. Descomprime pronosticos.zip")
print("   2. Sube las 4 im√°genes .png a tu repositorio")
print("   3. Reemplaza las im√°genes antiguas")